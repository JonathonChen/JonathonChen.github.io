{"meta":{"title":"博客","subtitle":null,"description":null,"author":"陈志远","url":"https://jonathonchen.github.io"},"pages":[],"posts":[{"title":"vue 生命周期","slug":"vue.生命周期","date":"2017-08-24T03:19:07.529Z","updated":"2017-08-24T03:29:45.917Z","comments":true,"path":"2017/08/24/vue.生命周期/","link":"","permalink":"https://jonathonchen.github.io/2017/08/24/vue.生命周期/","excerpt":"","text":"前言 在使用vue一个多礼拜后，感觉现在还停留在初级阶段，虽然知道怎么和后端做数据交互，但是对于mounted这个挂载还不是很清楚的。放大之，对vue的生命周期不甚了解。只知道简单的使用，而不知道为什么，这对后面的踩坑是相当不利的。 因为我们有时候会在几个钩子函数里做一些事情，什么时候做，在哪个函数里做，我们不清楚。 vue生命周期简介","categories":[],"tags":[]},{"title":"懒加载原理","slug":"懒加载","date":"2017-08-24T03:16:18.150Z","updated":"2017-08-24T03:17:58.128Z","comments":true,"path":"2017/08/24/懒加载/","link":"","permalink":"https://jonathonchen.github.io/2017/08/24/懒加载/","excerpt":"","text":"懒加载的原理 原理：先将img标签中的src链接设为同一张图片（空白图片），将其真正的图片地址存储再img标签的自定义属性中（比如data-src）。当js监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到src属性中，达到懒加载的效果。 这样做能防止页面一次性向服务器响应大量请求导致服务器响应慢，页面卡顿或崩溃等问题。 代码实现 既然懒加载的原理是基于判断元素是否出现在窗口可视范围内，首先我们写一个函数判断元素是否出现在可视范围内： 12345678910function isVisible($node)&#123; var winH = $(window).height(), scrollTop = $(window).scrollTop(), offSetTop = $(window).offSet().top; if (offSetTop &lt; winH + scrollTop) &#123; return true; &#125; else &#123; return false; &#125;&#125; 再添加上浏览器的事件监听函数，让浏览器每次滚动就检查元素是否出现在窗口可视范围内： 12345$(window).on(&quot;scroll&quot;, function&#123; if (isVisible($node))&#123; console.log(true); &#125;&#125;) 我们已经很接近了，现在我们要做的是，让元素只在第一次被检查到时打印true，之后就不再打印了 1234567891011var hasShowed = false;$(window).on(&quot;sroll&quot;,function&#123; if (hasShowed) &#123; return; &#125; else &#123; if (isVisible($node)) &#123; hasShowed = !hasShowed; console.log(true); &#125; &#125;&#125;)","categories":[],"tags":[]},{"title":"JavaScript深入之闭包(转)","slug":"闭包","date":"2017-08-24T03:00:10.217Z","updated":"2017-08-24T03:14:17.978Z","comments":true,"path":"2017/08/24/闭包/","link":"","permalink":"https://jonathonchen.github.io/2017/08/24/闭包/","excerpt":"","text":"JavaScript深入之闭包 介绍理论上的闭包和实践上的闭包，以及从作用域链的角度解析经典的闭包题。 定义MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量 举个例子1234567var a = 1;function foo() &#123; console.log(a);&#125;foo(); foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛…… 还真是这样的！ 所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。 咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？ 别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义： ECMAScript中，闭包指的是： 1.从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 2.从实践角度：以下函数才算是闭包： (1).即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） (2).在代码中引用了自由变量 分析1234567891011var scope = &quot;global scope&quot;;function checkscope()&#123; var scope = &quot;local scope&quot;; function f()&#123; return scope; &#125; return f;&#125;var foo = checkscope();foo(); 首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。 另一个与这段代码相似的例子，在《JavaScript深入之执行上下文》中有着非常详细的分析。如果看不懂以下的执行过程，建议先阅读这篇文章。 这里直接给出简要的执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？ 以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……) 然而 JavaScript 却是可以的！ 必刷题1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为：123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的作用域链为：123data[0]Context = &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。 data[1] 和 data[2] 是一样的道理。 所以让我们改成闭包看看：12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function (i) &#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125;data[0]();data[1]();data[2](); 当执行到 data[0] 函数之前，此时全局上下文的 VO 为：123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 跟没改之前一模一样。 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125; 匿名函数执行上下文的 AO 为：123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是 0。 data[1] 和 data[2] 是一样的道理。 转自 https://juejin.im/post/590159d8a22b9d0065c2d918","categories":[],"tags":[]},{"title":"vue loading加载动画组件","slug":"vue loading组件","date":"2017-08-19T13:09:14.515Z","updated":"2017-08-19T13:59:15.000Z","comments":true,"path":"2017/08/19/vue loading组件/","link":"","permalink":"https://jonathonchen.github.io/2017/08/19/vue loading组件/","excerpt":"","text":"实现效果实现了加载是颜色的变化以及进度条的变化 下面是代码实现 html页面测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style&gt; .spinner &#123; transform-origin: center; animation: rotator 6s linear infinite; background-color:#cccccc; width:150px; height:150px; &#125; @keyframes rotator &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(270deg); &#125; &#125; .path &#123; stroke-dasharray: 187; stroke-dashoffset: 0; transform-origin: center; animation: dash 2s ease-in-out infinite, colors 4s ease-in-out infinite; &#125; @keyframes colors &#123; 0% &#123; stroke: #4285F4; &#125; 25% &#123; stroke: #DE3E35; &#125; 50% &#123; stroke: #F7C223; &#125; 75% &#123; stroke: #1B9A59; &#125; 100% &#123; stroke: #4285F4; &#125; &#125; @keyframes dash &#123; 0% &#123; stroke-dashoffset: 187; &#125; 50% &#123; stroke-dashoffset: 93.5; &#125; 100% &#123; stroke-dashoffset: 0; &#125; &#125;&lt;/style&gt;&lt;body&gt; &lt;svg class=&quot;spinner&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;circle class=&quot;path&quot; stroke=&quot;red&quot; fill=&quot;none&quot; stroke-width=&quot;6&quot; cx=&quot;75&quot; cy=&quot;75&quot; r=&quot;30&quot;&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/body&gt;&lt;/html&gt; vue Loading组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;template&gt; &lt;div class=&quot;loading-component&quot;&gt; &lt;svg class=&quot;spinner&quot; :style=&quot;loadingSize&quot; viewBox=&quot;0 0 66 66&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;circle class=&quot;path&quot; :style=&quot;loadingColor&quot; fill=&quot;none&quot; :stroke-width=&quot;stroke&quot; cx=&quot;33&quot; cy=&quot;33&quot; r=&quot;30&quot;&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/ecmascript-6&quot;&gt; export default &#123; props: &#123; size: &#123; type: Number, default: 50 &#125;, stroke: &#123; type: Number, default: 3.5 &#125;, color: &#123; type: String, default: &apos;#ed424b&apos; &#125; &#125;, computed: &#123; loadingSize() &#123; const newSize = this.size + &apos;px&apos; return &#123; width: newSize, height: newSize &#125; &#125;, loadingColor() &#123; return &#123; stroke: this.color &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; type=&quot;text/less&quot;&gt; .loading-component &#123; display: inline-block; pointer-events: none; will-change: transform, opacity; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); &#125; //2 * pi * r = 188.4 @offset: 187; @duration: 1.4s; //设置外层旋转形成加载的效果 .spinner &#123; transform-origin: center; animation: rotator @duration linear infinite; &#125; @keyframes rotator &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(270deg); &#125; &#125; .path &#123; stroke-dasharray: @offset; stroke-dashoffset: 0; transform-origin: center; // 设置颜色变化以及dash长度的变化 animation: dash @duration ease-in-out infinite, colors @duration ease-in-out infinite; &#125; @keyframes colors &#123; 0% &#123; stroke: #4285F4; &#125; 25% &#123; stroke: #DE3E35; &#125; 50% &#123; stroke: #F7C223; &#125; 75% &#123; stroke: #1B9A59; &#125; 100% &#123; stroke: #4285F4; &#125; &#125; //让空白部分慢慢减少 @keyframes dash &#123; 0% &#123; stroke-dashoffset: @offset; &#125; 50% &#123; stroke-dashoffset: @offset/4; &#125; 100% &#123; stroke-dashoffset: @offset; &#125; &#125;&lt;/style&gt;","categories":[],"tags":[]},{"title":"v-model本质（以底部导航切换为例子）","slug":"v-model","date":"2017-08-17T13:33:16.790Z","updated":"2017-08-17T13:47:46.823Z","comments":true,"path":"2017/08/17/v-model/","link":"","permalink":"https://jonathonchen.github.io/2017/08/17/v-model/","excerpt":"","text":"v-modelv-model本质是1&lt;input type=&quot;text&quot; v-bind:value=&quot;dataA&quot; v-on:input=&quot;dataA = $event.target.value&quot; /&gt; 1.Index页面该页面包含了m-tabbar和m-tabbar-item组件，目的是实现底部tab切换m-tabbar传入 v-mode:”select”实际上是v-bind:value=”select” v-on:input=”select = $event.target.value”v-bind:value=”select”传入的props(父-&gt;子)v-on:input=”select = $event.target.value” 监听$emit(‘input’,…)v-model 数据双向绑定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div&gt; &lt;m-tabbar v-model=&quot;select&quot;&gt; &lt;m-tabbar-item id=&apos;tab1&apos;&gt; &lt;img src=&quot;../assets/images/ic_tab_home_normal.png&quot; alt=&quot;&quot; slot=&quot;icon-normal&quot;&gt; &lt;img src=&quot;../assets/images/ic_tab_home_active.png&quot; alt=&quot;&quot; slot=&quot;icon-active&quot;&gt; 首页 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id=&apos;tab2&apos;&gt; &lt;img src=&quot;../assets/images/ic_tab_subject_normal.png&quot; alt=&quot;&quot; slot=&quot;icon-normal&quot;&gt; &lt;img src=&quot;../assets/images/ic_tab_subject_active.png&quot; alt=&quot;&quot; slot=&quot;icon-active&quot;&gt; 书影音 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id=&apos;tab3&apos;&gt; &lt;img src=&quot;../assets/images/ic_tab_status_normal.png&quot; alt=&quot;&quot; slot=&quot;icon-normal&quot;&gt; &lt;img src=&quot;../assets/images/ic_tab_status_active.png&quot; alt=&quot;&quot; slot=&quot;icon-active&quot;&gt; 广播 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id=&apos;tab4&apos;&gt; &lt;img src=&quot;../assets/images/ic_tab_group_normal.png&quot; alt=&quot;&quot; slot=&quot;icon-normal&quot;&gt; &lt;img src=&quot;../assets/images/ic_tab_group_active.png&quot; alt=&quot;&quot; slot=&quot;icon-active&quot;&gt; 小组 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id=&apos;tab5&apos;&gt; &lt;img src=&quot;../assets/images/ic_tab_profile_normal.png&quot; alt=&quot;&quot; slot=&quot;icon-normal&quot;&gt; &lt;img src=&quot;../assets/images/ic_tab_profile_active.png&quot; alt=&quot;&quot; slot=&quot;icon-active&quot;&gt; 我的 &lt;/m-tabbar-item&gt; &lt;/m-tabbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import mTabbar from &apos;../components/tabbar&apos; import mTabbarItem from &apos;../components/tabbar-item&apos; export default &#123; name: &apos;index&apos;, components: &#123; mTabbar, mTabbarItem &#125;, data()&#123; return&#123; select:&apos;tab1&apos; &#125; &#125;, watch:&#123; select:function()&#123; console.log(this.select); &#125; &#125; &#125;&lt;/script&gt; 1.父组件接收v-bind:value属性123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=&quot;m-tabbar&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:[&apos;value&apos;]&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;.m-tabbar&#123; display: flex; flex-direction: row; position: fixed; bottom: 0; left: 0; right: 0; width: 100%; overflow: hidden; height: 50px; background: #fff; border-top: 1px solid #e4e4e4;&#125;&lt;/style&gt; 2.子组件接收id属性值，通过$parent.$emit(‘input’,id)向父组件传递当前点击id的值，父组件由on来接收123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;a class=&quot;m-tabbar-item&quot; :class=&quot;&#123;&apos;is-active&apos;:isActive&#125;&quot; @click=&quot;$parent.$emit(&apos;input&apos;,id)&quot;&gt; &lt;span class=&quot;m-tabbar-item-icon&quot; v-show=&quot;!isActive&quot;&gt;&lt;slot name=&quot;icon-normal&quot;&gt;&lt;/slot&gt;&lt;/span&gt; &lt;span class=&quot;m-tabbar-item-icon&quot; v-show=&quot;isActive&quot;&gt;&lt;slot name=&quot;icon-active&quot;&gt;&lt;/slot&gt;&lt;/span&gt; &lt;span class=&quot;m-tabbar-item-text&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/span&gt; &lt;/a&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:[&apos;id&apos;], computed: &#123; isActive()&#123; if(this.$parent.value===this.id)&#123; return true; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;.m-tabbar-item&#123; flex: 1; text-align: center; .m-tabbar-item-icon&#123; display: block; padding-top: 2px; img&#123; width: 28px; height: 28px; &#125; &#125; .m-tabbar-item-text&#123; display: block; font-size: 10px; color:#949494; &#125; &amp;.is-active&#123; .m-tabbar-item-text&#123; color: #42bd56; &#125; &#125;&#125;&lt;/style&gt;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-08-15T14:26:13.022Z","updated":"2017-08-15T14:26:13.022Z","comments":true,"path":"2017/08/15/hello-world/","link":"","permalink":"https://jonathonchen.github.io/2017/08/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}