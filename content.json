{"meta":{"title":"博客","subtitle":null,"description":null,"author":"陈志远","url":"https://jonathonchen.github.io"},"pages":[],"posts":[{"title":"解决https请求下发送http请求问题","slug":"解决https请求下发送http请求问题 ","date":"2017-08-24T10:02:58.022Z","updated":"2017-08-24T10:04:04.730Z","comments":true,"path":"2017/08/24/解决https请求下发送http请求问题 /","link":"","permalink":"https://jonathonchen.github.io/2017/08/24/解决https请求下发送http请求问题 /","excerpt":"","text":"在https页面下的带有相对路径的请求都会与页面的协议保持一致。如果想在https页面下发送http的请求，如果只把链接写死成为http的\b绝对路径是不够的，这样会导致http的请求与总页面https的请求的session不一致。 为什么呢？原因是https的请求中服务器发回的cookie是标记为”secure”的，而http的请求时非”secure”,”由于在服务器端secure”的cookie不会兼容非”secure”的，所以当http的请求携带着同一jsessionid的cookie到达服务器时，服务器拒绝非”secure”，进而返回的结果是一个新的非”secure”的cookie，于是两个session就不同了。 怎么解决呢？由原因分析可知，两个session不同，更具体说是cookie的状态不同。那么办法是，在接收到第一个https请求的响应后 到 发送下面的http请求之前，将cookie去”secure”状态，但是又要保证jsessionid不变。具体操作可以新建一个cookie(新建的是非”secure”状态)，然后赋予同一个jessionid，然后加入response中。 代码如下： 1234Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, req.getSession().getId());cookie.setPath(req.getContextPath());resp.addCookie(cookie); 本文转载自http://blog.csdn.NET/songgeabc/article/details/18192057","categories":[],"tags":[]},{"title":"CSS兼容","slug":"css兼容","date":"2017-08-24T09:33:45.774Z","updated":"2017-08-24T09:51:43.948Z","comments":true,"path":"2017/08/24/css兼容/","link":"","permalink":"https://jonathonchen.github.io/2017/08/24/css兼容/","excerpt":"","text":"一、基本的css兼容：1.hack 可能很多人喜欢用css hack的形式去兼容ie浏览器，但是我自己用起来感觉其实不好使 。ie7-就不考虑了，问题在哪呢，就在ie8的甑别上，你怎么让样式只对ie8起作用。1234.selector &#123; color: #ff0\\0;/*ie8*/ color: #f00\\9\\0;/*ie9+*/&#125; （这个hack是可以区分ie8和ie9的，之前由于未知原因导致浏览器测试不成功，重装系统后发现是可用的，后来又在多台机器上测试过，证明是正确的。很抱歉误导了大家，特此修正，仍然建议用文档注释的方式去独立写hack，当然最好是可以优雅降级，避免使用css hack。） ２．注释 更好用的是什么呢，是用ie浏览器独有的文档注释的方式。像这样：12345&lt;!DOCTYPE html&gt;&lt;!--[if IE 8 ]&gt; &lt;html class=&quot;ie8&quot; lang=&quot;en&quot;&gt; &lt;![endif]--&gt;&lt;!--[if IE 9 ]&gt; &lt;html class=&quot;ie9&quot; lang=&quot;en&quot;&gt; &lt;![endif]--&gt;&lt;!--[if (gt IE 9)|!(IE)]&gt;&lt;!--&gt;&lt;html lang=&quot;en&quot;&gt; &lt;!--&lt;![endif]--&gt; 好处：可以独立的维护处理兼容ie浏览器的样式表，又不会淹没在一大堆css hack标识中，只需要在独立对ie8应用样式规则的地方，copy该条规则，然后在前面加上 .ie8然后就能随便写了，对付ie9也一样。 3. 对于360双核这种找抽浏览器，据说添加以下头部meta信息可以使得网页用webkit内核渲染：1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; IE=edge：保持使用最高级别模式显示内容； chrome=1：谷歌的外挂插件Google Chrome Frame（谷歌内嵌浏览器框架GCF），使用IE浏览网页时实际上是使用Chrome浏览器内核渲染，最低支持IE6，但前提是客户端已经安装GCF。 但实际上这个meta标识是ie浏览器所识别的（详情：ies-compatibility-features-for-site-developers/)，并不是公认的标准，所以用双核的浏览器会傲娇。当然360也会傲娇，所以有时你会发现360并不能总是（也可能是我本人rp差）以chrome内核渲染你的按现代标准开发的网页。 那么试试这个吧，添加： 这个meta标识是360自家实现的(详情：meta.html)，表示强制要求360这造福中国社会万千网民的浏览器用chrome的内核渲染网页。 ok，一行代码搞定360绝大部分的兼容。 ————————以下转———————————————- 二、ie8的css兼容现在说说ie8下的css问题： 1、ie8支持:first-child,但不支持:last-child。因为前者是css2.1标准，后者是css3标准。参下：1CSS 2.1 selectors：Basic CSS selectors including: * (universal selector), &gt; (child selector), :first-child, :link, :visited, :active, :hover, :focus, :lang(), + (adjacent sibling selector), [attr], [attr=&quot;val&quot;], [attr~=&quot;val&quot;], [attr|=&quot;bar&quot;], .foo (class selector), #foo (id selector) 2、 为什么会发现上面的奇怪的东西（怪我css2.1和css3分不清），因为编译sass文件后发现ie8下的样式基本全歇菜了。需要注意的是，如果浏览器 不支持的选择器和支持的选择器写在一起，那么整条规则就不起作用了。比如你不小心创造了一个伪元素（是真的伪哦）.bb:bb-child, .cc{background:#333;}那么这整条规则就不起作用了，所有浏览器在此情况下都会歇菜,.cc的样式就丢失了。3、 input设置了左右padding，but输入较多内容时padding还是会消失。这个问题是无解的，ie浏览器她就是这么渲染input的，解决方法是在input 外面套一层div，用div设置左右padding，border，width和height，input只需要设置width和weight为100% 即可。另外，正常来讲，如果没有明确设置height的值，那么设置的line-height值就是height的值，but对于ie8，如果input 设置了 line-height，那么input必须设置height，否则input的内容显示有问题，会上下隐藏部分内容，她就是要躲猫猫。4、 为什么上面我不用input的伪元素进行设置而要嵌套多一层div呢？因为input，img，iframe等元素不支持伪元素 -_-||。:before 和:after伪元素指定了一个元素文档树内容之前和之后的内容。与’content’属性联用,指定了插入的内容（也就是你必须显性设置content 属性这两个伪家伙才能在文档中显示出来，哪怕设置content属性为空字符串也行）。作为DOM元素，伪元素都是在容器内进行渲染的, input，img，iframe等元素都不能包含其他元素，也就是不是容器，所以不能通过伪元素插入内容。5、 table中如果不是严格的用于表格，而是用于奇葩的局部布局时（我也想问为什么用来布局。。），td设置成inline-block可以排成一行，但是 ie8和ie9 下，如果td中的内容很长，即使td设置了宽度，td也会撑开并占用td设置的margin（废话，td是没有margin可言的），直到挤占所有的td 宽度之和为tr的宽度。但是td设置成float：left；就能表现成block。这个不清楚为什么，但是管用。。6、父元素的左padding会和子元素的左margin重叠。这个是没有好好实现盒子模型的事情了，包容吧。。7、sprite图中的icons之间最好留空白间隔，哪怕间隔1px也好，否则ie8下会出现使用了某一个icon当背景，icon后面跟着的其他icon也顺带显示了一小部分的bug，所以icons之间还是要适当留白，不要太省。三、ie11部分css问题1、 ie11下很多元素表现和其他浏览器不一致，比如对应用了同一样式（不设置 高度）的div，其他浏览器解析的高度是一致的，但是ie11下该div有可能高度偏大，由此导致一些排版上的问题，所以，如果发现元素排版上下偏移的问题，查看此元素或其当代元素是否设置了高度，统一添上高度一切都ok了。2、抱歉，ie11问题确实不多。四、结尾附上一个关于css优先级的奇谈首先我们知道： 1、id选择器优先级权重比class选择器大一个数量级，class选择器权重比标签选择器大一个数量级；2、class选择器和属性选择器同优先级;3、样式的优先程度需要根据第1条规则计算整体的优先级，按选择器权重计算各条样式规则中所有选择器优先级之和，哪条规则权重大，那条就说了算。如果相同那么后面的覆盖前面的。4、像这种.dog &gt; p开挂，多了特殊符号的，并不会增加优势，还是和 .dog p优先级一样。然后可以抛出一个问题了： 对于下面的文档结构，分别对 p | .p | div p | .parent | #parent设置color属性，那么优先级如何呢？123&lt;div id=&quot;parent&quot; class=&quot;parent&quot;&gt; &lt;p class=&quot;p&quot;&gt;p&lt;/p&gt;&lt;/div&gt; 结果表现：也就是 .p &gt; div p &gt; p &gt; #parent &gt; .parentid选择器居然比p选择器优先级还低！将p元素和div元素分开看，.p &gt; div p &gt; p 很正常， #parent &gt; .parent也很正常。所以问题关键在子级p和父级#parent, 子级的选择器优先级比父级的选择器优先级高，或者说继承的优先级程度比自身的优先级低！ 嵌套多一层看看就知道是不是了，分别对#parent | div | p设置color属性：1234567&lt;div id=&quot;parent&quot; class=&quot;parent&quot;&gt; &lt;div class=&quot;mid&quot;&gt; &lt;p id=&quot;p&quot; class=&quot;p&quot;&gt;p&lt;/p&gt; &lt;div&gt;&lt;/div&gt; 结果确实是p &gt; div &gt; #parent： 即使应用两个选择器也无济于事，依然是p &gt;#parent div 只要能定位到p元素，那么父级选择器的权重就起作用了,一试便知，对#parent p | #p 设置同样的样式结果是这样的：嗯，确实如此。所以： 5、css样式优先级还和继承有关，继承的优先级不如本身应用的优先级高。","categories":[],"tags":[]},{"title":"深入理解HTTP协议（转）","slug":"深入理解HTTP协议（转）","date":"2017-08-24T03:56:40.019Z","updated":"2017-08-24T04:01:03.793Z","comments":true,"path":"2017/08/24/深入理解HTTP协议（转）/","link":"","permalink":"https://jonathonchen.github.io/2017/08/24/深入理解HTTP协议（转）/","excerpt":"","text":"从浏览器地址栏输入url到显示页面的步骤(以HTTP为例) 在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树： Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树: 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 js解析如下： 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件 显示页面（HTML解析过程中会逐步显示页面）","categories":[],"tags":[]},{"title":"SUPERAGENT","slug":"批处理HTTP模块SuperAgent","date":"2017-08-24T03:52:10.831Z","updated":"2017-08-24T03:55:10.887Z","comments":true,"path":"2017/08/24/批处理HTTP模块SuperAgent/","link":"","permalink":"https://jonathonchen.github.io/2017/08/24/批处理HTTP模块SuperAgent/","excerpt":"","text":"最近在写爬虫，看了下node里面有啥关于ajax的模块,发现superagent这个模块灰常的好用。好东西要和大家分享，话不多说，开始吧～ 什么是SuperAgentsuperagent它是一个强大并且可读性很好的轻量级ajaxAPI，是一个关于HTTP方面的一个库，而且它可以将链式写法玩的出神入化。1var superagent = require(&apos;superagent&apos;); superagent .post(&apos;/api&apos;) .send(&#123; &apos;key&apos;: &apos;value&apos; &#125;) .set(&apos;header_key&apos;, &apos;header_value&apos;) .end(function(err, res) &#123; if (err) &#123; //do something &#125; else &#123; //do something &#125; &#125;) 接下来，让我们逐一的对SuperAgent的一些特性进行分析吧～🚀 设置请求头 这一点在写爬虫的时候十分的有用,因为有些网站可能设置了一些限制条件,比如它会去匹配你的请求头里面的一些字段, 像User-Agent Referer等,如果你没有设置这些请求头的话，可能就抓取不到数据咯～ SuperAgent里面设置请求头很简单,通过使用set()方法就可以设置了，有两种方式 单个单个的设置 1234567891011121314151617181920superagent .get(&apos;/api&apos;) .set(&apos;Referer&apos;,&apos;https://www.google.com&apos;) .set(&apos;Accept&apos;,&apos;image/webp,image/*,*/*;q=0.8&apos;) .end(function(req,res)&#123; //do something &#125;) 放在一起设置 superagent .get(&apos;/api&apos;) .set(&#123; &apos;Referer&apos;,&apos;https://www.google.com&apos;, &apos;Accept&apos;,&apos;image/webp,image/*,*/*;q=0.8&apos; &#125;) .end(function(req,res)&#123; //do something &#125;) GET请求方式 我相信大家都一定见过这样类型的URL:http://localhost:8080/api和http://localhost:8080/api?id=1&amp;price=10,就是GET方式可以带上参数,也可以不带上参数。不带参数的就不说了,相信大家都会,在superagent中我们可以通过query()方法给URL后面带上参数,有4种写法 12345678910111213141516171819202122232425//接下来所形成的URL为/api?name=An&amp;age=20&amp;sex=male//第一种superagent .get(/api) .query(&#123;name:&apos;An&apos;&#125;) .query(&#123;age:20&#125;) .query(&#123;sex:&apos;male&apos;&#125;) .end(cb)//第二种superagent .get(/api) .query(&#123;name:&apos;An&apos;,age:20,sex:&apos;male&apos;&#125;) .end(cb)//第三种 superagent .get(/api) .query(&apos;name=An&amp;age=20&amp;sex=male&apos;) .end(cb)//第四种 superagent .get(/api) .query(&apos;name=An&apos;) .query(&apos;age=20&apos;) .query(&apos;sex=male&apos;) .end(cb) head请求 head请求也可以通过query()的方式进行传递参数,大家可以参考👆的GET请求 POST/PUT请求 这两种请求，一般是要给服务端发送数据，现在文本数据的方式一般都以json的方式传递。我们可以在请求头里设置Accept=application/json，从而服务器可以根据请求头来生成json数据(在java开发后台时可以这样) 在superagent里面，默认的数据传递格式是json，所以下面几种种方式是相同的。 1234567891011121314151617superagent .post(&apos;/api&apos;) .set(&apos;Accept&apos;,&apos;application/json&apos;) .send(&apos;&#123;&quot;name&quot;:&quot;An&quot;,&quot;age&quot;:20,&quot;sex&quot;:&quot;male&quot;&#125;&apos;) .end(cb)//等价于 ==&gt;superagent .post(&apos;/api&apos;) .send(&#123;name:&quot;An&quot;,age:20,sex:&quot;male&quot;&#125;) .end(cb)//等价于 ==&gt;superagent .post(&apos;/api&apos;) .send(&#123;name:&quot;An&quot;&#125;) .send(&#123;age:20&#125;) .sex(&#123;sex:&apos;male&apos;&#125;) .end(cb) 当然，除了json的形式去传递，我们还有一种很常见的表单提交，在superagent里，也实现了模拟表单的提交数据类型application/x-www-form-urlencoded， 我们可以通过type(&apos;form&apos;)方法进行转换 12345superagent .post(&apos;/api&apos;) .type(&apos;form&apos;) .send(&#123;name:&apos;An&apos;,age:20&#125;) // name=An&amp;age=20 .end(cb) 有时候，我们也会在POST请求时，将一些参数放在URL上面，那这个时候还是可以用query()方法 设置Content-Type的两种快速方式 type()方法 accept()方法 这两种方法都可以接受规范的MIME格式,以及图片和xml等这些格式的数据。 123456789101112superagent .post(&apos;/api&apos;) .type(&apos;application/json&apos;) .type(&apos;png&apos;)// 等价于==&gt;superagent .post(&apos;/api&apos;) .accept(&apos;application/json&apos;) .accept(&apos;png&apos;) 分析处理response body superagent可以帮你解析返回的数据,当前支持三种类型的数据application/x-www-form-urlencoded application/json 和multipart/form-data JSON/Urlencoded 解析后的数据会以对象的形式存在,可以通过res.body来得到。 &apos;{&quot;name&quot;:&quot;An&quot;}&apos; //JSON String //解析 ==&gt; { name:&quot;An&quot; //JSON Object } Multipart 这种格式的数据的处理，superagent是通过Formidable模块，它是主要处理文件上传的模块，大家可以去了解下，也是Node里面十分常用的模块，也很简单易上手。上传的文件的信息可以在res.files去查看，当然，我觉得这个属性用的比较少，这只是个人观点了～ Response的属性 res.text包含为被解析的响应数据 res.body上文提到了，包含解析的数据，但是目前只支持三种格式 res.header响应头,是一个Object res.type &amp; res.charset 类型和编码格式 res.status状态码 终止请求 req.abort() 暂停请求 req.timeout(ms) ms表示毫秒为单位的时间 Basic Access Authentication 首先先简单的介绍下Basic Access Authenication，它是在web应用中，通过直接提供用户名、密码来进行验证身份的一种优化的解决方案。 原理是将用户名和密码通过:连接,形成username:password然后再进行base64加密，发送到服务器后再进行解密得到用户名和密码,进行进一步的匹配验证。参考文章:HTTP Basic Authentication认证。 在superagent里，有两种方式进行验证 12345678superagent .get(&apos;http://username:password@localhost&apos;) .end(cb)//等价于 ==&gt;superagent .get(&apos;http://localhost&apos;) .auth(&apos;username&apos;,&apos;password&apos;) .end(cb) 可以通过pipe管道流入流出数据 我想大家应该知道node里面有个核心特性就是stream，如果不知道的，可以参考:nodejs中流(stream)的理解,举两个栗子： 1234567891011121314//第一个例子var fs = require(&apos;fs&apos;);var request = require(&apos;superagent&apos;);var postJson = fs.createReadStream(&apos;./postDataJson&apos;);var req= request.post(&apos;/api&apos;);req.accept(&apos;json&apos;);stream.pipe(req);//第二个例子var fs = require(&apos;fs&apos;);var request = require(&apos;superagent&apos;);var getData = fs.createWriteStream(&apos;./getData&apos;);var res= request.get(&apos;/api&apos;);res.pipe(getData); 添加多个附件 superagent也提供了一些高级的API，如果你想添加多个附件可以使用attach(name,[path],[filename]),其中你可以通过filename来自定义上传后文件的文件名 12345request .post(&apos;/upload&apos;) .attach(&apos;avator&apos;,&apos;/path/a.png&apos;,&apos;An.png&apos;) .attach(&apos;photo&apos;,&apos;/path/b.png&apos;) .end(cb) 复合请求 superagent也支持复合请求,比如你想上传一个带有你的姓名和邮箱的图片，那可以通过field(name,value)方法 123456request .post(&apos;/upload&apos;) .field(&apos;name&apos;,&apos;An&apos;) .field(&apos;age&apos;:20) .attach(&apos;avator&apos;,&apos;/path/a.png&apos;,&apos;An.png&apos;) .end(cb) 错误处理 有时候我们可能会因为不同的原因得到4XX或者5XX的错误，这个时候我们确实是可以从end(function(err,res){...})里的err得到错误信息,比如er.status错误的状态码啥的，但是有些时候我们想去处理这些错误，重新发送一个别的请求啥的，那么这个时候我们可以通过on(&apos;error&apos;,handleFn)去处理了 12345request .post(&apos;/api&apos;) .send(data) .on(&apos;error&apos;,handleFn) .end(cb);","categories":[],"tags":[]},{"title":"Node.js的学习--使用cheerio抓取网页数据","slug":"Node.js的学习--使用cheerio抓取网页数据","date":"2017-08-24T03:49:33.357Z","updated":"2017-08-24T03:51:18.092Z","comments":true,"path":"2017/08/24/Node.js的学习--使用cheerio抓取网页数据/","link":"","permalink":"https://jonathonchen.github.io/2017/08/24/Node.js的学习--使用cheerio抓取网页数据/","excerpt":"","text":"打算要写一个公开课网站，缺少数据，就决定去网易公开课去抓取一些数据。 前一阵子看过一段时间的Node.js，而且Node.js也比较适合做这个事情，就打算用Node.js去抓取数据。 关键是抓取到网页之后如何获取到想要的数据呢？然后就发现了cheerio，用来解析html非常方便，就像在浏览器中使用jquery一样。 使用如下命令安装cheerio npm install cheerio Cheerio安装完成， 我们就可以开始工作了。 首先让我们来看一段javascript代码 这段代码可以下载任意一个网页的内容。将其放入到curl.js中，并导出。12345678910111213141516171819 var http = require(&quot;http&quot;); // Utility function that downloads a URL and invokes// callback with the data.function download(url, callback) &#123; http.get(url, function(res) &#123; var data = &quot;&quot;; res.on(&apos;data&apos;, function (chunk) &#123; data += chunk; &#125;); res.on(&quot;end&quot;, function() &#123; callback(data); &#125;); &#125;).on(&quot;error&quot;, function() &#123; callback(null); &#125;);&#125;exports.download = download; 然后是使用cheerio解析html，找到想要的数据。 我们先来自己分析一下页面。我们要抓取http://v.163.com/special/opencourse/englishs1.html这个页面中的视频，视频的地址都在下载的按钮里。其中一个下载按钮的html的代码如下：12&lt;a class=&quot;downbtn&quot; href=&quot;http://mov.bn.netease.com/mobilev/2013/1/F/G/S8KTEF7FG.mp4&quot; id=&quot;M8KTEKR84&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt; 我们取到其中的href属性，只需要进行如下选择即可12$(&quot;a.downbtn&quot;).attr(&quot;href&quot;); 在是现实，我们可以在index.js中写入如下代码12345678910111213141516171819var cheerio = require(&quot;cheerio&quot;);var server = require(&quot;./curl&quot;); var url = &quot;http://v.163.com/special/opencourse/englishs1.html&quot;server.download(url, function(data) &#123; if (data) &#123; //console.log(data); var $ = cheerio.load(data); $(&quot;a.downbtn&quot;).each(function(i, e) &#123; console.log($(e).attr(&quot;href&quot;)); &#125;); console.log(&quot;done&quot;); &#125; else &#123; console.log(&quot;error&quot;); &#125; &#125;);","categories":[],"tags":[]},{"title":"IIS部署","slug":"iis部署","date":"2017-08-24T03:46:48.674Z","updated":"2017-08-24T03:47:33.598Z","comments":true,"path":"2017/08/24/iis部署/","link":"","permalink":"https://jonathonchen.github.io/2017/08/24/iis部署/","excerpt":"","text":"IIS名词介绍1.IIS简介 Internet Information Service 微软服务器，windows系统都自带这个功能 2.互联网相关名词介绍 服务器Server;通常是指服务器硬件。还有服务器软件（程序） 服务器软件是运行在电脑上的程序，电脑也可以当做一个服务器 URL：统一资源定位符 https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1492594445597&amp;di=1b28e8ff63505088aff8a1f3567bd44e&amp;imgtype=0&amp;src=http%3A%2F%2Fmvimg2.meitudata.com%2F55713dd0165c89055.jpg 域名domain name address: www.baidu.com ip地址：命令提示符 –&gt; ipconfig 使用ping www.baidu.com可以把域名转换成ip地址 DNS： Domain name system域名解析服务 开启IIS服务器123456789101112* 1.打开控制面板--&gt;程序--&gt;启用或关闭windows功能--&gt;internet information service--&gt;全部勾选* 2.使用localhost或者127.0.0.1访问本地服务器* 3.默认站点，IIS服务器默认站点在c:\\inetpub\\wwwroot文件夹下* 4.默认文档，打开服务器的时候加载显示的页面。可以上移提高优先级，也可以添加自己想要显示的页面。* 5.注意浏览器缓存，可能会加载以前缓存的页面，而没有加载自己添加的页面* 6.目录浏览，把服务器下的文件以目录的形式展示，这种方式很不安全，因为会把所有文件暴露出来* 7.开启目录浏览，需要把默认文档关掉或者删除所有的默认文档* 8.如果被人通过ip地址访问你的电脑。需要把防火墙关闭* 9.添加站点，端口需要改，要指定路径，如果不能访问，没有权限，需要修改权限* 10.文件夹--&gt;右键属性--&gt;安全--&gt;编辑--&gt;添加--&gt;everyone--&gt;全部控制--&gt;应用* 11.ftp文件传输协议，上传下载文件* 12.http超文本传输协议","categories":[],"tags":[]},{"title":"git远程操作","slug":"git远程操作","date":"2017-08-24T03:45:31.879Z","updated":"2017-08-24T09:30:41.923Z","comments":true,"path":"2017/08/24/git远程操作/","link":"","permalink":"https://jonathonchen.github.io/2017/08/24/git远程操作/","excerpt":"","text":"git远程操作 在开源中国的码云平台做代码的远程提交 12345678910111213码云地址:https://git.oschina.net登录注册:此步骤省略具体操作步骤 1. 在平台上通过新建项目创建一个代码仓库 2. 把远程仓库的代码clone到本地 在本地电脑上创建一个文件夹(通过cd命令进入此文件夹)，执行以下命令 git clone https://.... # 通过clone命令把代码clone到本地 3. 使用编辑器打开文件夹,对内容做修改 4. 修改之后对代码做本地的缓存和提交 git add . #把文件加入缓存区 git commit -m &apos;提交信息&apos; #把代码提交到本地仓库 5. 把本地代码push(推送)到远程服务器 git push git客户端gui工具 tortoisegit sourcetree github上创建个人主页 在github上创建一个项目名为 xxx.github.io的仓库此仓库中放置的静态html文件可以直接通过外网地址进行访问 创建个人github主页的步骤为 1231. 打开github,登陆个人账号2. 创建项目,项目名为 用户名.github.io3. 在此项目中提交一些可以直接访问的静态html文件 查看、添加、提交、删除、找回，重置修改文件git help # 显示command的help git show # 显示某次提交的内容 git show $id git co – # 抛弃工作区修改 git co . # 抛弃工作区修改 git add # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm # 从版本库中删除文件 git rm –cached # 从版本库中删除文件，但不删除文件 git reset # 从暂存区恢复到工作文件 git reset – . # 从暂存区恢复到工作文件 git reset –hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am “some comments” git ci –amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件diffgit diff # 比较当前文件和暂存区文件差异 git diff git diff &lt; id2&gt; # 比较两次提交之间的差异 git diff .. # 在两个分支之间比较 git diff –staged # 比较暂存区和版本库差异 git diff –cached # 比较暂存区和版本库差异 git diff –stat # 仅仅比较统计信息 查看提交记录git log git log # 查看该文件每次提交记录 git log -p # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log –stat #查看提交统计信息 tig Mac上可以使用tig代替diff和log，brew install tig Git 本地分支管理 查看、切换、创建和删除分支git br -r # 查看远程分支 git br # 创建新的分支 git br -v # 查看各个分支最后提交信息 git br –merged # 查看已经被合并到当前分支的分支 git br –no-merged # 查看尚未被合并到当前分支的分支 git co # 切换到某个分支 git co -b # 创建新的分支，并且切换过去 git co -b # 基于branch创建新的new_branch git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git co $id -b # 把某次历史提交记录checkout出来，创建成一个分支 git br -d # 删除某个分支 git br -D # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebasegit merge # 将branch分支合并到当前分支 git merge origin/master –no-ff # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master # 将master rebase到branch，相当于： git co &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge Git补丁管理(方便在多台机器上开发同步时用) git diff &gt; ../sync.patch # 生成补丁 git apply ../sync.patch # 打补丁 git apply –check ../sync.patch #测试补丁能否成功 Git暂存管理git stash # 暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地 git pull –no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 git fetch origin # 抓取远程仓库更新 git merge origin/master # 将远程主分支合并到本地当前分支 git co –track origin/branch # 跟踪某个远程分支创建相应的本地分支 git co -b origin/ # 基于远程分支创建本地分支，功能同上 git push # push所有分支 git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin # 创建远程分支， origin是远程仓库名 git push origin : # 创建远程分支 git push origin : #先删除本地分支(git br -d )，然后再push删除远程分支 Git远程仓库管理GitHubgit remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址 git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm # 删除远程仓库 创建远程仓库git clone –bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git –bare init # 在服务器创建纯仓库 git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库git branch –set-upstream master origin/master git branch –set-upstream develop origin/develop","categories":[],"tags":[]},{"title":"mongodb mongoose node中间件增删改查方法","slug":"mongose中间件","date":"2017-08-24T03:41:43.826Z","updated":"2017-08-24T03:44:22.732Z","comments":true,"path":"2017/08/24/mongose中间件/","link":"","permalink":"https://jonathonchen.github.io/2017/08/24/mongose中间件/","excerpt":"","text":"官网 http://mongoosejs.com/docs/api.html#model_Model.update 命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344#model.js$whereincrementmodelModelremovesaveaggregatebulkWritecountcreatedeleteManydeleteOnediscriminatordistinctensureIndexesfindfindByIdfindByIdAndRemovefindByIdAndUpdatefindOnefindOneAndRemovefindOneAndUpdategeoNeargeoSearchhydrateinsertManymapReducepopulateremovereplaceOnetranslateAliasesupdateupdateManyupdateOnewhere$wherebasebaseModelNamecollectiondbdiscriminatorsmodelNameschema","categories":[],"tags":[]},{"title":"vue 生命周期","slug":"vue.生命周期","date":"2017-08-24T03:19:07.529Z","updated":"2017-08-24T03:38:07.800Z","comments":true,"path":"2017/08/24/vue.生命周期/","link":"","permalink":"https://jonathonchen.github.io/2017/08/24/vue.生命周期/","excerpt":"","text":"前言 在使用vue一个多礼拜后，感觉现在还停留在初级阶段，虽然知道怎么和后端做数据交互，但是对于mounted这个挂载还不是很清楚的。放大之，对vue的生命周期不甚了解。只知道简单的使用，而不知道为什么，这对后面的踩坑是相当不利的。 因为我们有时候会在几个钩子函数里做一些事情，什么时候做，在哪个函数里做，我们不清楚。 vue生命周期简介 生命周期探究&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/vue/2.1.3/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message : &quot;xuxiao is boy&quot; &#125;, beforeCreate: function () &#123; console.group(&apos;beforeCreate 创建前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125;, created: function () &#123; console.group(&apos;created 创建完毕状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeMount: function () &#123; console.group(&apos;beforeMount 挂载前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + (this.$el)); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, mounted: function () &#123; console.group(&apos;mounted 挂载结束状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeUpdate: function () &#123; console.group(&apos;beforeUpdate 更新前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, updated: function () &#123; console.group(&apos;updated 更新完成状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, beforeDestroy: function () &#123; console.group(&apos;beforeDestroy 销毁前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); create 和 mounted 相关 beforecreated：el 和 data 并未初始化created:完成了 data 数据的初始化，el没有beforeMount：完成了 el 和 data 初始化mounted ：完成挂载 生命周期总结 beforecreate : 举个栗子：可以在这加个loading事件created ：在这结束loading，还做一些初始化，实现函数自执行mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情beforeDestory： 你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容 参考文献 https://segmentfault.com/q/10… http://www.cnblogs.com/gagag/…","categories":[],"tags":[]},{"title":"懒加载原理","slug":"懒加载","date":"2017-08-24T03:16:18.150Z","updated":"2017-08-24T03:17:58.128Z","comments":true,"path":"2017/08/24/懒加载/","link":"","permalink":"https://jonathonchen.github.io/2017/08/24/懒加载/","excerpt":"","text":"懒加载的原理 原理：先将img标签中的src链接设为同一张图片（空白图片），将其真正的图片地址存储再img标签的自定义属性中（比如data-src）。当js监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到src属性中，达到懒加载的效果。 这样做能防止页面一次性向服务器响应大量请求导致服务器响应慢，页面卡顿或崩溃等问题。 代码实现 既然懒加载的原理是基于判断元素是否出现在窗口可视范围内，首先我们写一个函数判断元素是否出现在可视范围内： 12345678910function isVisible($node)&#123; var winH = $(window).height(), scrollTop = $(window).scrollTop(), offSetTop = $(window).offSet().top; if (offSetTop &lt; winH + scrollTop) &#123; return true; &#125; else &#123; return false; &#125;&#125; 再添加上浏览器的事件监听函数，让浏览器每次滚动就检查元素是否出现在窗口可视范围内： 12345$(window).on(&quot;scroll&quot;, function&#123; if (isVisible($node))&#123; console.log(true); &#125;&#125;) 我们已经很接近了，现在我们要做的是，让元素只在第一次被检查到时打印true，之后就不再打印了 1234567891011var hasShowed = false;$(window).on(&quot;sroll&quot;,function&#123; if (hasShowed) &#123; return; &#125; else &#123; if (isVisible($node)) &#123; hasShowed = !hasShowed; console.log(true); &#125; &#125;&#125;)","categories":[],"tags":[]},{"title":"JavaScript深入之闭包(转)","slug":"闭包","date":"2017-08-24T03:00:10.217Z","updated":"2017-08-24T03:14:17.978Z","comments":true,"path":"2017/08/24/闭包/","link":"","permalink":"https://jonathonchen.github.io/2017/08/24/闭包/","excerpt":"","text":"JavaScript深入之闭包 介绍理论上的闭包和实践上的闭包，以及从作用域链的角度解析经典的闭包题。 定义MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量 举个例子1234567var a = 1;function foo() &#123; console.log(a);&#125;foo(); foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛…… 还真是这样的！ 所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。 咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？ 别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义： ECMAScript中，闭包指的是： 1.从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 2.从实践角度：以下函数才算是闭包： (1).即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） (2).在代码中引用了自由变量 分析1234567891011var scope = &quot;global scope&quot;;function checkscope()&#123; var scope = &quot;local scope&quot;; function f()&#123; return scope; &#125; return f;&#125;var foo = checkscope();foo(); 首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。 另一个与这段代码相似的例子，在《JavaScript深入之执行上下文》中有着非常详细的分析。如果看不懂以下的执行过程，建议先阅读这篇文章。 这里直接给出简要的执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？ 以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……) 然而 JavaScript 却是可以的！ 必刷题1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为：123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的作用域链为：123data[0]Context = &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。 data[1] 和 data[2] 是一样的道理。 所以让我们改成闭包看看：12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function (i) &#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125;data[0]();data[1]();data[2](); 当执行到 data[0] 函数之前，此时全局上下文的 VO 为：123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 跟没改之前一模一样。 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125; 匿名函数执行上下文的 AO 为：123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是 0。 data[1] 和 data[2] 是一样的道理。 转自 https://juejin.im/post/590159d8a22b9d0065c2d918","categories":[],"tags":[]},{"title":"vue loading加载动画组件","slug":"vue loading组件","date":"2017-08-19T13:09:14.515Z","updated":"2017-08-19T13:59:15.000Z","comments":true,"path":"2017/08/19/vue loading组件/","link":"","permalink":"https://jonathonchen.github.io/2017/08/19/vue loading组件/","excerpt":"","text":"实现效果实现了加载是颜色的变化以及进度条的变化 下面是代码实现 html页面测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style&gt; .spinner &#123; transform-origin: center; animation: rotator 6s linear infinite; background-color:#cccccc; width:150px; height:150px; &#125; @keyframes rotator &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(270deg); &#125; &#125; .path &#123; stroke-dasharray: 187; stroke-dashoffset: 0; transform-origin: center; animation: dash 2s ease-in-out infinite, colors 4s ease-in-out infinite; &#125; @keyframes colors &#123; 0% &#123; stroke: #4285F4; &#125; 25% &#123; stroke: #DE3E35; &#125; 50% &#123; stroke: #F7C223; &#125; 75% &#123; stroke: #1B9A59; &#125; 100% &#123; stroke: #4285F4; &#125; &#125; @keyframes dash &#123; 0% &#123; stroke-dashoffset: 187; &#125; 50% &#123; stroke-dashoffset: 93.5; &#125; 100% &#123; stroke-dashoffset: 0; &#125; &#125;&lt;/style&gt;&lt;body&gt; &lt;svg class=&quot;spinner&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;circle class=&quot;path&quot; stroke=&quot;red&quot; fill=&quot;none&quot; stroke-width=&quot;6&quot; cx=&quot;75&quot; cy=&quot;75&quot; r=&quot;30&quot;&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/body&gt;&lt;/html&gt; vue Loading组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;template&gt; &lt;div class=&quot;loading-component&quot;&gt; &lt;svg class=&quot;spinner&quot; :style=&quot;loadingSize&quot; viewBox=&quot;0 0 66 66&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;circle class=&quot;path&quot; :style=&quot;loadingColor&quot; fill=&quot;none&quot; :stroke-width=&quot;stroke&quot; cx=&quot;33&quot; cy=&quot;33&quot; r=&quot;30&quot;&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/ecmascript-6&quot;&gt; export default &#123; props: &#123; size: &#123; type: Number, default: 50 &#125;, stroke: &#123; type: Number, default: 3.5 &#125;, color: &#123; type: String, default: &apos;#ed424b&apos; &#125; &#125;, computed: &#123; loadingSize() &#123; const newSize = this.size + &apos;px&apos; return &#123; width: newSize, height: newSize &#125; &#125;, loadingColor() &#123; return &#123; stroke: this.color &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; type=&quot;text/less&quot;&gt; .loading-component &#123; display: inline-block; pointer-events: none; will-change: transform, opacity; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); &#125; //2 * pi * r = 188.4 @offset: 187; @duration: 1.4s; //设置外层旋转形成加载的效果 .spinner &#123; transform-origin: center; animation: rotator @duration linear infinite; &#125; @keyframes rotator &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(270deg); &#125; &#125; .path &#123; stroke-dasharray: @offset; stroke-dashoffset: 0; transform-origin: center; // 设置颜色变化以及dash长度的变化 animation: dash @duration ease-in-out infinite, colors @duration ease-in-out infinite; &#125; @keyframes colors &#123; 0% &#123; stroke: #4285F4; &#125; 25% &#123; stroke: #DE3E35; &#125; 50% &#123; stroke: #F7C223; &#125; 75% &#123; stroke: #1B9A59; &#125; 100% &#123; stroke: #4285F4; &#125; &#125; //让空白部分慢慢减少 @keyframes dash &#123; 0% &#123; stroke-dashoffset: @offset; &#125; 50% &#123; stroke-dashoffset: @offset/4; &#125; 100% &#123; stroke-dashoffset: @offset; &#125; &#125;&lt;/style&gt;","categories":[],"tags":[]},{"title":"v-model本质（以底部导航切换为例子）","slug":"v-model","date":"2017-08-17T13:33:16.790Z","updated":"2017-08-17T13:47:46.823Z","comments":true,"path":"2017/08/17/v-model/","link":"","permalink":"https://jonathonchen.github.io/2017/08/17/v-model/","excerpt":"","text":"v-modelv-model本质是1&lt;input type=&quot;text&quot; v-bind:value=&quot;dataA&quot; v-on:input=&quot;dataA = $event.target.value&quot; /&gt; 1.Index页面该页面包含了m-tabbar和m-tabbar-item组件，目的是实现底部tab切换m-tabbar传入 v-mode:”select”实际上是v-bind:value=”select” v-on:input=”select = $event.target.value”v-bind:value=”select”传入的props(父-&gt;子)v-on:input=”select = $event.target.value” 监听$emit(‘input’,…)v-model 数据双向绑定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div&gt; &lt;m-tabbar v-model=&quot;select&quot;&gt; &lt;m-tabbar-item id=&apos;tab1&apos;&gt; &lt;img src=&quot;../assets/images/ic_tab_home_normal.png&quot; alt=&quot;&quot; slot=&quot;icon-normal&quot;&gt; &lt;img src=&quot;../assets/images/ic_tab_home_active.png&quot; alt=&quot;&quot; slot=&quot;icon-active&quot;&gt; 首页 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id=&apos;tab2&apos;&gt; &lt;img src=&quot;../assets/images/ic_tab_subject_normal.png&quot; alt=&quot;&quot; slot=&quot;icon-normal&quot;&gt; &lt;img src=&quot;../assets/images/ic_tab_subject_active.png&quot; alt=&quot;&quot; slot=&quot;icon-active&quot;&gt; 书影音 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id=&apos;tab3&apos;&gt; &lt;img src=&quot;../assets/images/ic_tab_status_normal.png&quot; alt=&quot;&quot; slot=&quot;icon-normal&quot;&gt; &lt;img src=&quot;../assets/images/ic_tab_status_active.png&quot; alt=&quot;&quot; slot=&quot;icon-active&quot;&gt; 广播 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id=&apos;tab4&apos;&gt; &lt;img src=&quot;../assets/images/ic_tab_group_normal.png&quot; alt=&quot;&quot; slot=&quot;icon-normal&quot;&gt; &lt;img src=&quot;../assets/images/ic_tab_group_active.png&quot; alt=&quot;&quot; slot=&quot;icon-active&quot;&gt; 小组 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id=&apos;tab5&apos;&gt; &lt;img src=&quot;../assets/images/ic_tab_profile_normal.png&quot; alt=&quot;&quot; slot=&quot;icon-normal&quot;&gt; &lt;img src=&quot;../assets/images/ic_tab_profile_active.png&quot; alt=&quot;&quot; slot=&quot;icon-active&quot;&gt; 我的 &lt;/m-tabbar-item&gt; &lt;/m-tabbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import mTabbar from &apos;../components/tabbar&apos; import mTabbarItem from &apos;../components/tabbar-item&apos; export default &#123; name: &apos;index&apos;, components: &#123; mTabbar, mTabbarItem &#125;, data()&#123; return&#123; select:&apos;tab1&apos; &#125; &#125;, watch:&#123; select:function()&#123; console.log(this.select); &#125; &#125; &#125;&lt;/script&gt; 1.父组件接收v-bind:value属性123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=&quot;m-tabbar&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:[&apos;value&apos;]&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;.m-tabbar&#123; display: flex; flex-direction: row; position: fixed; bottom: 0; left: 0; right: 0; width: 100%; overflow: hidden; height: 50px; background: #fff; border-top: 1px solid #e4e4e4;&#125;&lt;/style&gt; 2.子组件接收id属性值，通过$parent.$emit(‘input’,id)向父组件传递当前点击id的值，父组件由on来接收123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;a class=&quot;m-tabbar-item&quot; :class=&quot;&#123;&apos;is-active&apos;:isActive&#125;&quot; @click=&quot;$parent.$emit(&apos;input&apos;,id)&quot;&gt; &lt;span class=&quot;m-tabbar-item-icon&quot; v-show=&quot;!isActive&quot;&gt;&lt;slot name=&quot;icon-normal&quot;&gt;&lt;/slot&gt;&lt;/span&gt; &lt;span class=&quot;m-tabbar-item-icon&quot; v-show=&quot;isActive&quot;&gt;&lt;slot name=&quot;icon-active&quot;&gt;&lt;/slot&gt;&lt;/span&gt; &lt;span class=&quot;m-tabbar-item-text&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/span&gt; &lt;/a&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:[&apos;id&apos;], computed: &#123; isActive()&#123; if(this.$parent.value===this.id)&#123; return true; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;.m-tabbar-item&#123; flex: 1; text-align: center; .m-tabbar-item-icon&#123; display: block; padding-top: 2px; img&#123; width: 28px; height: 28px; &#125; &#125; .m-tabbar-item-text&#123; display: block; font-size: 10px; color:#949494; &#125; &amp;.is-active&#123; .m-tabbar-item-text&#123; color: #42bd56; &#125; &#125;&#125;&lt;/style&gt;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-08-15T14:26:13.022Z","updated":"2017-08-15T14:26:13.022Z","comments":true,"path":"2017/08/15/hello-world/","link":"","permalink":"https://jonathonchen.github.io/2017/08/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}