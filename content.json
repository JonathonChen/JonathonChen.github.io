{"meta":{"title":"博客","subtitle":null,"description":null,"author":"陈志远","url":""},"pages":[{"title":"About","date":"2017-08-25T10:54:14.936Z","updated":"2017-08-16T08:34:47.338Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-08-25T10:54:14.942Z","updated":"2017-08-16T08:34:47.338Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-08-25T10:54:14.961Z","updated":"2017-08-16T08:34:47.339Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-08-25T10:54:14.956Z","updated":"2017-08-25T06:42:55.618Z","comments":true,"path":"categories/type1/index.html","permalink":"/categories/type1/index.html","excerpt":"","text":"Category: type1 | Hexo Hexo Home Archives + Categories + Tags About (function (window) { var INSIGHT_CONFIG = { TRANSLATION: { POSTS: 'Posts', PAGES: 'Pages', CATEGORIES: 'Categories', TAGS: 'Tags', UNTITLED: '(Untitled)', }, ROOT_URL: '/', CONTENT_URL: '/content.json', }; window.INSIGHT_CONFIG = INSIGHT_CONFIG; })(window); Home Archives + Categories + Tags About PPOffice Web Developer &amp; Designer Harbin, China FOLLOW 5 posts 1 tag type1 js变量提升和函数提升 2016-08-25 type1 tags1 recent js变量的只声明不赋值 2017-08-25 js上下文 2017-08-25 js作用域和作用域链 2017-08-25 2017-08-25 type1 js变量提升和函数提升 2016-08-25 categories type11 archives August 20174August 20161 tags tags11 tag cloud tags1 links Hexo &copy; 2017 John Doe Powered by Hexo. Theme by PPOffice var disqus_config = function () { this.page.identifier = ''; }; (function() { var d = document, s = d.createElement('script'); s.src = '//' + 'hexo-theme-icarus' + '.disqus.com/count.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })();"},{"title":"","date":"2017-08-25T10:54:14.965Z","updated":"2017-08-25T06:42:55.621Z","comments":true,"path":"tags/tags1/index.html","permalink":"/tags/tags1/index.html","excerpt":"","text":"Tag: tags1 | Hexo Hexo Home Archives + Categories + Tags About (function (window) { var INSIGHT_CONFIG = { TRANSLATION: { POSTS: 'Posts', PAGES: 'Pages', CATEGORIES: 'Categories', TAGS: 'Tags', UNTITLED: '(Untitled)', }, ROOT_URL: '/', CONTENT_URL: '/content.json', }; window.INSIGHT_CONFIG = INSIGHT_CONFIG; })(window); Home Archives + Categories + Tags About PPOffice Web Developer &amp; Designer Harbin, China FOLLOW 5 posts 1 tag #tags1 js变量提升和函数提升 2016-08-25 type1 tags1 recent js变量的只声明不赋值 2017-08-25 js上下文 2017-08-25 js作用域和作用域链 2017-08-25 2017-08-25 type1 js变量提升和函数提升 2016-08-25 categories type11 archives August 20174August 20161 tags tags11 tag cloud tags1 links Hexo &copy; 2017 John Doe Powered by Hexo. Theme by PPOffice var disqus_config = function () { this.page.identifier = ''; }; (function() { var d = document, s = d.createElement('script'); s.src = '//' + 'hexo-theme-icarus' + '.disqus.com/count.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })();"}],"posts":[{"title":"link和import","slug":"link和import","date":"2017-02-19T16:00:00.000Z","updated":"2017-08-27T13:17:08.201Z","comments":true,"path":"2017/02/20/link和import/","link":"","permalink":"/2017/02/20/link和import/","excerpt":"","text":"@import url（）机制是不同于link的，link是在加载页面前把css加载完毕，而@import url（）则是读取完文件后在加载，所以会出现一开始没有css样式，闪烁一下出现样式后的页面(网速慢的情况下)。 @import 是css2里面的，所以古老的ie5不支持。 当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。 link除了能加载css外还能定义RSS，定义rel连接属性，@import只能加载css","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"/tags/css/"}]},{"title":"元素竖向的百分比设定","slug":"元素竖向的百分比设定","date":"2017-02-14T16:00:00.000Z","updated":"2017-08-27T13:16:09.711Z","comments":true,"path":"2017/02/15/元素竖向的百分比设定/","link":"","permalink":"/2017/02/15/元素竖向的百分比设定/","excerpt":"","text":"一、 相对父元素 宽度： [max/min-]width、left、right、padding、margin 等 高度 [max/min-]height、top、bottom 等 二、相对于继承字号的： font-size 等； 三、相对于自身字号的： line-height（line-height与height相等垂直居中原理可参见http://www.jianshu.com/p/6e4d683f6cf2） 等； 四、 相对于自身宽高的： border-radius、background-size、transform: translate()、transform-origin、zoom、clip-path 等； 五、 特殊算法的：background-position（方向长度 / 该方向除背景图之外部分总长度 * 100）、filter 系列函数等； 可以对元素的margin设置百分数，百分数是相对于父元素的width计算，不管是margin-top/margin-bottom还是margin-left/margin-right。（padding同理） 如果没有为元素声明width，在这种情况下，元素框的总宽度包括外边距取决于父元素的width，这样可能得到“流式”页面，即元素的外边距会扩大或缩小以适应父元素的实际大小。如果对这个文档设置样式，使其元素使用百分数外边距，当用户修改浏览窗口的宽度时，外边距会随之扩大或缩小。 为什么margin-top/margin-bottom的百分数也是相对于width而不是height呢？CSS权威指南中的解释： 我们认为，正常流中的大多数元素都会足够高以包含其后代元素（包括外边距），如果一个元素的上下外边距时父元素的height的百分数，就可能导致一个无限循环，父元素的height会增加，以适应后代元素上下外边距的增加，而相应的，上下外边距因为父元素height的增加也会增加，如果循环。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"/tags/css/"}]},{"title":"CSS兼容","slug":"css兼容","date":"2017-02-05T16:00:00.000Z","updated":"2017-08-27T13:02:04.708Z","comments":true,"path":"2017/02/06/css兼容/","link":"","permalink":"/2017/02/06/css兼容/","excerpt":"","text":"一、基本的css兼容：1.hack 可能很多人喜欢用css hack的形式去兼容ie浏览器，但是我自己用起来感觉其实不好使 。ie7-就不考虑了，问题在哪呢，就在ie8的甑别上，你怎么让样式只对ie8起作用。1234.selector &#123; color: #ff0\\0;/*ie8*/ color: #f00\\9\\0;/*ie9+*/&#125; （这个hack是可以区分ie8和ie9的，之前由于未知原因导致浏览器测试不成功，重装系统后发现是可用的，后来又在多台机器上测试过，证明是正确的。很抱歉误导了大家，特此修正，仍然建议用文档注释的方式去独立写hack，当然最好是可以优雅降级，避免使用css hack。）http://www.cnblogs.com/mofish/p/3822879.html ２．注释 更好用的是什么呢，是用ie浏览器独有的文档注释的方式。像这样：12345&lt;!DOCTYPE html&gt;&lt;!--[if IE 8 ]&gt; &lt;html class=\"ie8\" lang=\"en\"&gt; &lt;![endif]--&gt;&lt;!--[if IE 9 ]&gt; &lt;html class=\"ie9\" lang=\"en\"&gt; &lt;![endif]--&gt;&lt;!--[if (gt IE 9)|!(IE)]&gt;&lt;!--&gt;&lt;html lang=\"en\"&gt; &lt;!--&lt;![endif]--&gt; 好处：可以独立的维护处理兼容ie浏览器的样式表，又不会淹没在一大堆css hack标识中，只需要在独立对ie8应用样式规则的地方，copy该条规则，然后在前面加上 .ie8然后就能随便写了，对付ie9也一样。 3. 对于360双核这种找抽浏览器，据说添加以下头部meta信息可以使得网页用webkit内核渲染：1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; IE=edge：保持使用最高级别模式显示内容； chrome=1：谷歌的外挂插件Google Chrome Frame（谷歌内嵌浏览器框架GCF），使用IE浏览网页时实际上是使用Chrome浏览器内核渲染，最低支持IE6，但前提是客户端已经安装GCF。 但实际上这个meta标识是ie浏览器所识别的（详情：ies-compatibility-features-for-site-developers/)，并不是公认的标准，所以用双核的浏览器会傲娇。当然360也会傲娇，所以有时你会发现360并不能总是（也可能是我本人rp差）以chrome内核渲染你的按现代标准开发的网页。 那么试试这个吧，添加： 这个meta标识是360自家实现的(详情：meta.html)，表示强制要求360这造福中国社会万千网民的浏览器用chrome的内核渲染网页。 ok，一行代码搞定360绝大部分的兼容。 ————————以下转———————————————- 二、ie8的css兼容现在说说ie8下的css问题： 1、ie8支持:first-child,但不支持:last-child。因为前者是css2.1标准，后者是css3标准。参下：1CSS 2.1 selectors：Basic CSS selectors including: * (universal selector), &gt; (child selector), :first-child, :link, :visited, :active, :hover, :focus, :lang(), + (adjacent sibling selector), [attr], [attr=\"val\"], [attr~=\"val\"], [attr|=\"bar\"], .foo (class selector), #foo (id selector) 2、 为什么会发现上面的奇怪的东西（怪我css2.1和css3分不清），因为编译sass文件后发现ie8下的样式基本全歇菜了。需要注意的是，如果浏览器 不支持的选择器和支持的选择器写在一起，那么整条规则就不起作用了。比如你不小心创造了一个伪元素（是真的伪哦）.bb:bb-child, .cc{background:#333;}那么这整条规则就不起作用了，所有浏览器在此情况下都会歇菜,.cc的样式就丢失了。3、 input设置了左右padding，but输入较多内容时padding还是会消失。这个问题是无解的，ie浏览器她就是这么渲染input的，解决方法是在input 外面套一层div，用div设置左右padding，border，width和height，input只需要设置width和weight为100% 即可。另外，正常来讲，如果没有明确设置height的值，那么设置的line-height值就是height的值，but对于ie8，如果input 设置了 line-height，那么input必须设置height，否则input的内容显示有问题，会上下隐藏部分内容，她就是要躲猫猫。4、 为什么上面我不用input的伪元素进行设置而要嵌套多一层div呢？因为input，img，iframe等元素不支持伪元素 -_-||。:before 和:after伪元素指定了一个元素文档树内容之前和之后的内容。与’content’属性联用,指定了插入的内容（也就是你必须显性设置content 属性这两个伪家伙才能在文档中显示出来，哪怕设置content属性为空字符串也行）。作为DOM元素，伪元素都是在容器内进行渲染的, input，img，iframe等元素都不能包含其他元素，也就是不是容器，所以不能通过伪元素插入内容。5、 table中如果不是严格的用于表格，而是用于奇葩的局部布局时（我也想问为什么用来布局。。），td设置成inline-block可以排成一行，但是 ie8和ie9 下，如果td中的内容很长，即使td设置了宽度，td也会撑开并占用td设置的margin（废话，td是没有margin可言的），直到挤占所有的td 宽度之和为tr的宽度。但是td设置成float：left；就能表现成block。这个不清楚为什么，但是管用。。6、父元素的左padding会和子元素的左margin重叠。这个是没有好好实现盒子模型的事情了，包容吧。。7、sprite图中的icons之间最好留空白间隔，哪怕间隔1px也好，否则ie8下会出现使用了某一个icon当背景，icon后面跟着的其他icon也顺带显示了一小部分的bug，所以icons之间还是要适当留白，不要太省。三、ie11部分css问题1、 ie11下很多元素表现和其他浏览器不一致，比如对应用了同一样式（不设置 高度）的div，其他浏览器解析的高度是一致的，但是ie11下该div有可能高度偏大，由此导致一些排版上的问题，所以，如果发现元素排版上下偏移的问题，查看此元素或其当代元素是否设置了高度，统一添上高度一切都ok了。2、抱歉，ie11问题确实不多。四、结尾附上一个关于css优先级的奇谈首先我们知道： 1、id选择器优先级权重比class选择器大一个数量级，class选择器权重比标签选择器大一个数量级；2、class选择器和属性选择器同优先级;3、样式的优先程度需要根据第1条规则计算整体的优先级，按选择器权重计算各条样式规则中所有选择器优先级之和，哪条规则权重大，那条就说了算。如果相同那么后面的覆盖前面的。4、像这种.dog &gt; p开挂，多了特殊符号的，并不会增加优势，还是和 .dog p优先级一样。然后可以抛出一个问题了： 对于下面的文档结构，分别对 p | .p | div p | .parent | #parent设置color属性，那么优先级如何呢？123&lt;div id=\"parent\" class=\"parent\"&gt; &lt;p class=\"p\"&gt;p&lt;/p&gt;&lt;/div&gt; 结果表现：也就是 .p &gt; div p &gt; p &gt; #parent &gt; .parentid选择器居然比p选择器优先级还低！将p元素和div元素分开看，.p &gt; div p &gt; p 很正常， #parent &gt; .parent也很正常。所以问题关键在子级p和父级#parent, 子级的选择器优先级比父级的选择器优先级高，或者说继承的优先级程度比自身的优先级低！ 嵌套多一层看看就知道是不是了，分别对#parent | div | p设置color属性：1234567&lt;div id=\"parent\" class=\"parent\"&gt; &lt;div class=\"mid\"&gt; &lt;p id=\"p\" class=\"p\"&gt;p&lt;/p&gt; &lt;div&gt;&lt;/div&gt; 结果确实是p &gt; div &gt; #parent： 即使应用两个选择器也无济于事，依然是p &gt;#parent div 只要能定位到p元素，那么父级选择器的权重就起作用了,一试便知，对#parent p | #p 设置同样的样式结果是这样的：嗯，确实如此。所以： 5、css样式优先级还和继承有关，继承的优先级不如本身应用的优先级高。 6、css3的calc()浏览器支持IE9+、FF4.0+、Chrome19+、Safari6+","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"/tags/css/"}]},{"title":"去除inline-block元素间间距的N种方法(转)","slug":"去除inline-block元素间间距的N种方法","date":"2017-02-04T16:00:00.000Z","updated":"2017-08-27T10:03:12.000Z","comments":true,"path":"2017/02/05/去除inline-block元素间间距的N种方法/","link":"","permalink":"/2017/02/05/去除inline-block元素间间距的N种方法/","excerpt":"","text":"一、现象描述真正意义上的inline-block水平呈现的元素间，换行显示或空格分隔的情况下会有间距，很简单的个例子： 二、移除空格12345678 #box&#123; width:1000px; background:#000; height:1000px; &#125; .c&#123; display: inline-block;&#125; 12345&lt;div id=\"box\"&gt; &lt;div class=\"c\" style=\"background-color: green;width: 50%;height: 100px;\" &gt;&lt;/div&gt; &lt;div class=\"c\" style=\"background-color: red;width: 50%;height: 100px;\"&gt;&lt;/div&gt;&lt;/div&gt; 这种效果是两个div不能并排123&lt;div id=\"box\"&gt; &lt;div class=\"c\" style=\"background-color: green;width: 50%;height: 100px;\" &gt;&lt;/div&gt;&lt;div class=\"c\" style=\"background-color: red;width: 50%;height: 100px;\"&gt;&lt;/div&gt;&lt;/div&gt; 这种效果是两个div并排 三、使用margin负值1234.space a &#123; display: inline-block; margin-right: -3px;&#125; margin负值的大小与上下文的字体和文字大小相关例如，对于12像素大小的上下文，Arial字体的margin负值为-3像素，Tahoma和Verdana就是-4像素，而Geneva为-6像素。由于外部环境的不确定性，以及最后一个元素多出的父margin值等问题，这个方法不适合大规模使用。 四、让闭合标签吃胶囊12345&lt;div class=\"space\"&gt; &lt;a href=\"##\"&gt;惆怅 &lt;a href=\"##\"&gt;淡定 &lt;a href=\"##\"&gt;热血&lt;/a&gt;&lt;/div&gt; 注意，为了向下兼容IE6/IE7等喝蒙牛长大的浏览器，最后一个列表的标签的结束（闭合）标签不能丢。 在HTML5中，我们直接：12345&lt;div class=\"space\"&gt; &lt;a href=\"##\"&gt;惆怅 &lt;a href=\"##\"&gt;淡定 &lt;a href=\"##\"&gt;热血&lt;/div&gt; 五、使用font-size:0123456 .space &#123; font-size: 0;&#125;.space a &#123; font-size: 12px;&#125; 这个方法，基本上可以解决大部分浏览器下inline-block元素之间的间距(IE7等浏览器有时候会有1像素的间距)。不过有个浏览器，就是Chrome, 其默认有最小字体大小限制，因为，考虑到兼容性，我们还需要添加：类似下面的代码：1234.space &#123; font-size: 0; -webkit-text-size-adjust:none;&#125; 补充：根据小杜在评论中中的说法，目前Chrome浏览器已经取消了最小字体限制。因此，上面的-webkit-text-size-adjust:none;代码估计时日不多了。 六、使用letter-spacing类似下面的代码：123456.space &#123; letter-spacing: -3px;&#125;.space a &#123; letter-spacing: 0;&#125; 根据我去年的测试，该方法可以搞定基本上所有浏览器，包括吃“东鞋”、“西毒(胶囊)”、“南地(沟油)”、“北钙(三鹿)”的IE6/IE7浏览器，不过Opera浏览器下有蛋疼的问题：最小间距1像素，然后，letter-spacing再小就还原了。 七、使用word-spacing类似下面代码：123456.space &#123; word-spacing: -6px;&#125;.space a &#123; word-spacing: 0;&#125; 一个是字符间距(letter-spacing)一个是单词间距(word-spacing)，大同小异。据我测试，word-spacing的负值只要大到一定程度，其兼容性上的差异就可以被忽略。因为，貌似，word-spacing即使负值很大，也不会发生重叠。 您可以狠狠地点击这里：word-spacing与元素间距去除demo 与上面demo一样的效果，这里就不截图展示了。如果您使用Chrome浏览器，可能看到的是间距依旧存在。确实是有该问题，原因我是不清楚，不过我知道，可以添加display: table;或display:inline-table;让Chrome浏览器也变得乖巧。1234.space &#123; display: inline-table; word-spacing: -6px;&#125; 八、其他成品方法下面展示的是YUI 3 CSS Grids 使用letter-spacing和word-spacing去除格栅单元见间隔方法（注意，其针对的是block水平的元素，因此对IE8-浏览器做了hack处理）：12345678910111213.yui3-g &#123; letter-spacing: -0.31em; /* webkit */ *letter-spacing: normal; /* IE &lt; 8 重置 */ word-spacing: -0.43em; /* IE &lt; 8 &amp;&amp; gecko */&#125;.yui3-u &#123; display: inline-block; zoom: 1; *display: inline; /* IE &lt; 8: 伪造 inline-block */ letter-spacing: normal; word-spacing: normal; vertical-align: top;&#125; 以下是一个名叫RayM的人提供的方法：12345678910111213li &#123; display:inline-block; background: orange; padding:10px; word-spacing:0; &#125;ul &#123; width:100%; display:table; /* 调教webkit*/ word-spacing:-1em;&#125;.nav li &#123; *display:inline;&#125; 也就是上面一系列CSS方法的组组合合。 九、结语其他去除间距的方法肯定还有，欢迎大家通过评论方式进行补充。上文部分方法可能有测试不周全之处，因此，部分细节上可能会有纰漏，欢迎指正。 参考文章：Fighting the Space Between Inline Block Elements 转载来自张鑫旭-鑫空间-鑫生活[http://www.zhangxinxu.com]","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"/tags/html/"},{"name":"css","slug":"css","permalink":"/tags/css/"}]},{"title":"DIV+CSS 与不同 IE 版本等的兼容性","slug":"DIV+CSS 与不同 IE 版本等的兼容性","date":"2017-02-04T16:00:00.000Z","updated":"2017-08-27T12:39:48.036Z","comments":true,"path":"2017/02/05/DIV+CSS 与不同 IE 版本等的兼容性/","link":"","permalink":"/2017/02/05/DIV+CSS 与不同 IE 版本等的兼容性/","excerpt":"","text":"为了方便自己查询，省得每次遇到问题都要满世界搜，转篇实用的：DIV+CSS 与不同 IE 版本等的兼容性。一、!important (功能有限)随着 IE7 对 !important 的支持， !important 方法现在只针对 IE6 的兼容。（注意写法，记得该声明位置需要提前。）例如：1234#example &#123;width: 100px !important; /* IE7+FF */width: 200px; /* IE6 */&#125; 注意：IE6及以下浏览器有个比较显式的支持问题存在，!important并不覆盖掉在同一条样式的后面的规则。请看下述代码：示例代码：1div&#123;color:#f00!important;color:#000;&#125; 在上述代码中，IE6及以下浏览器div的文本颜色为#000，!important并没有覆盖后面的规则；其它浏览器下div的文本颜色为#f00 IE6及以下浏览器要使!important生效，可用以下代码：示例代码：12div&#123;color:#f00!important;&#125;div&#123;color:#000;&#125; 在上述代码中，IE6及以下浏览器中div的文本颜色表现与其它浏览器一致，都为#f00 ## 二、CSS HACK 的方法（新手可以看看，高手就当路过吧） 首先需要知道的是： 所有浏览器 通用 height: 100px;IE6 专用 _height: 100px;IE7 专用 +height: 100px;IE6、IE7 共用 height: 100px;IE7、FF 共用 height: 100px !important; 例如：12345#example &#123; height:100px; &#125; /* FF */*html #example &#123; height:200px; &#125; /* IE6 */*+html #example &#123; height:300px; &#125; /* IE7 */ 下面的这种方法比较简单 举几个例子： IE6 - IE7+FF1234#example &#123;height:100px; /* FF+IE7 */_height:200px; /* IE6 */&#125; 其实这个用上面说的第一种方法也可以1234#example &#123;height:100px !important; /* FF+IE7 */height:200px; /* IE6 */&#125; IE6+IE7 - FF 1234#example &#123;height:100px; /* FF */*height:200px; /* IE6+IE7 */&#125; IE6+FF - IE7 1234#example &#123;height:100px; /* IE6+FF */*+height:200px; /* IE7 */&#125; IE6 IE7 FF 各不相同 12345#example &#123;height:100px; /* FF */_height:200px; /* IE6 */*+height:300px; /* IE7 */&#125; 或：12345#example &#123;height:100px; /* FF */*height:300px; /* IE7 */_height:200px; /* IE6 */&#125; 需要注意的是，代码的顺序一定不能颠倒了，要不又前功尽弃了。因为浏览器在解释程序的时候，如果重名的话，会用后面的覆盖前面的，就象给变量赋值一个道理，所以我们把通用的放前面，越专用的越放后面。 解释一下4的代码： 读代码的时候，第一行 height:100px; 大家都通用，IE6 IE7 FF 都显示100px。到了第二行*height:300px; FF不认识这个属性，IE6 IE7 都认，所以FF还显示100px，而 IE6 IE7 把第一行得到的height属性给覆盖了，都显示300px。到了第三行 _height:200px; 只有IE6认识，所以 IE6 就又覆盖了在第二行得到的 height，最终显示200px。这样，三个浏览器都有自己的height属性了。 哦，差点忘了说了： *+html 对 IE7 的兼容 必须保证HTML顶部有如下声明：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “http://www.w3.org/TR/html4/loose.dtd&quot;&gt; 三、使用IE专用的条件注释 &lt;![endif]–&gt; &lt;![endif]–&gt; 貌似要编三套 css，我还没用过，先粘过来再说 IE 的 if 条件 Hack 除IE外都可识别 注:gt = Great Then 大于 = &gt; 大于号lt = Less Then 小于&lt; = &lt; 小于号gte = Great Then or Equal 大于或等于lte = Less Then or Equal 小于或等于 四、css filter的办法（据作者称是从国外某经典网站翻译过来的说）新建一个css样式如下：123456789#item &#123;width: 200px;height: 200px;background: red;&#125; 新建一个div,并使用前面定义的css的样式：1&lt;div &gt;some text here&lt;/div&gt; 在body表现这里加入 lang 属性，中文为zh：1&lt;body lang=\"en\"&gt; 现在对div元素再定义一个样式：12345*:lang(en) #item&#123;background:green !important;&#125; 这样做是为了用 !important 覆盖原来的 css 样式，由于:lang 选择器 ie7.0 并不支持，所以对这句话不会有任何作用，于是也达到了 ie6.0下同样的效果，但是很不幸地的是，safari 同样不支持此属性，所以需要加入以下 css 样式：12345#item:empty &#123;background: green !important&#125; :empty选择器为 CSS3 的规范，尽管 safari 并不支持此规范，但是还是会选择此元素，不管是否此元素存在，现在绿色会现在在除 ie 各版本以外的浏览器上。 五、FLOAT 闭合（clearing float）网页在某些浏览器上显示错位很多时候都是因为使用了 float 浮动而没有真正闭合，这也是 div 无法自适应高度的一个原因。如果父 div 没有设 float 而其子div却设了 float 的话,父div无法包住整个子 DIV，这种情况一般出现在一个父 DIV 下包含多个子 DIV。解决办法： 给父 DIV 也设上 float (不要骂我，我知道是废话) 在所有子 DIV 后新加一个空 DIV (不推荐，有些浏览器可以看见空 DIV 产生的空隙) 比如： .parent{width:100px;}.son1{float:left;width:20px;}.son2{float:left;width:80px;}.clear{clear:both;margin:0;parding0;height:0px;font-size:0px;} 万能 float 闭合 float的破坏性主要是指它会使父容器的高度塌陷，也就是父元素在高度计算的时候会忽略浮动的元素因此下面是来用来解决高度崩塌的问题，使之不会对后面的元素布局造成影响将以下代码加入Global CSS 中,给需要闭合的div加上 class=”clearfix” 即可,屡试不爽.代码: /* Clear Fix */ .clearfix:after { content:\".\"; display:block; height:0; clear:both; visibility:hidden; } .clearfix { display:inline-block; /*IE7+*/ } /* Hide from IE Mac \\*/ .clearfix {display:block;}/*IE6 IE7*/ /* End hide from IE Mac */ /* end of clearfix */ :after（伪对象）,设置在对象后发生的内容，通常和 content 配合使用，IE 不支持此伪对象，非 Ie 浏览器支持，所以并不影响到IE/WIN浏览器。这种的最麻烦。 overflow:auto（刚看到的，极力推荐）.clear{clear:both;height:0px;overflow:hidden;}只要在父 DIV 的CSS中加上 overflow:auto 就搞定。 举例：123.parent&#123;width:100px;overflow:auto&#125;.son1&#123;float:left;width:20px;&#125;.son2&#123;float:left;width:80px;&#125; 1234&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt; 作者原话：原理是，外围元素之所以不能很好的延伸，问题出在了 overflow 上，因为 overflow 不可见（见W3C的解释）。现在只要将给外围元素添加一个“overflow:auto”，就可以解决问题，结果是除了IE，真的可以解决。下来就要解决IE的问题了，再加上“_height:1%”，这个问题就完全解决了。 我试了一下，其实不加”_height:1%“在IE下也行，留着吧。 六、需要注意的一些兼容细节1, FF 下给 div 设置 padding 后会导致 width 和 height 增加(DIV的实际宽度=DIV宽+Padding), 但IE不会. 解决办法：给DIV设定IE、FF两个宽度，在IE的宽度前加上IE特有标记” * “号。 2, 页面居中问题. body {TEXT-ALIGN: center;} 在IE下足够了，但 FF 下失效。 解决办法：加上”MARGIN-RIGHT: auto; MARGIN-LEFT: auto; “ 3, 有的时候在IE6上看见一些奇怪的间隙，可我们高度明明设好了呀。(eg: inline-block) 解决办法：试试在有空隙的DIV上加上”font-size:0px;” 4, 关于手形光标. cursor: pointer. 而hand 只适用于 IE. 5, 浮动IE6产生的双倍距离1234#box&#123; float:left;width:100px;margin:0 0 0 100px;&#125; 这种情况之下IE6会产生200px的距离 解决办法：加上 display:inline，使浮动忽略 这里细说一下block,inline两个元素,Block元素的特点是:总是在新行上开始,高度,宽度,行高,边距都可以控制(块元素);Inline元素的特点是:和其他元素在同一行上,…不可控制(内嵌元素); #box{ display:block; //可以为内嵌元素模拟为块元素 display:inline; //实现同一行排列的的效果 6 页面的最小宽度 min-width是个非常方便的CSS命令，它可以指定元素最小也不能小于某个宽度，这样就能保证排版一直正确。但IE不认得min-这个定义，但实际上它把正常的width和height当作有min的情况来使。这样问题就大了，如果只用宽度和高度，正常的浏览器里这两个值就不会变，如果只用min-width和min-height的话，IE下面根本等于没有设置宽度和高度。比如要设置背景图片，这个宽度是比较重要的。 解决办法：为了让这一命令在IE上也能用，可以把一个 放到 标签下，然后为div指定一个类：然后CSS这样设计： #Container{min-width: 600px;width:e-xpression(document.body.clientWidth &lt; 600? “600px”: “auto” );}第一个min-width是正常的；但第2行的width使用了JavaScript，这只有IE才认得，这也会让你的HTML文档不太正规。它实际上通过javascript的判断来实现最小宽度。 7、UL和FORM标签的padding与margin ul标签在FF中默认是有padding值的,而在IE中只有margin默认有值。FORM标签在IE中,将会自动margin一些边距,而在FF中margin则是0； 解决办法：css中首先都使用这样的样式ul,form{margin:0;padding:0;}给定义死了,后面就不会为这个头疼了. 8 ,DIV浮动IE文本产生3象素的bug 下面这段是我在网上粘过来的 左边对象浮动，右边采用外补丁的左边距来定位，右边对象内的文本会离左边有3px的间距.12345678910111213#box&#123;float:left;width:800px;&#125;#left&#123;float:left;width:50%;&#125;#right&#123;width:50%;&#125;*html #left&#123;margin-right:-3px;//这句是关键&#125; HTML代码1234&lt;DIV id=box&gt;&lt;DIV id=left&gt;&lt;/DIV&gt;&lt;DIV id=right&gt;&lt;/DIV&gt;&lt;/DIV&gt; 针对上面这段代码，下面说一下我的理解： 第一、只要right定义了width属性，在FF下绝对就会两行显示第二、两个width都定义为百分比的话，就算都为100%在IE下也会一行显示。所以上面那句所谓“这句是关键”根本没用，不加也在一行，除非你width定义的是数值才用得上。 所以说上面这段代码其实用处不大，至少在FF下不行。其实只要只定义left的width就行了，right不定义width就不管在IE还是FF 下都能成功，但这样的话父DIV BOX并没有真正的包含LEFT和RIGHT两子DIV,可以用我上面说的第5种办法解决。最简单的办法就是在RIGHT中加上float:left就 OK了，真磨叽！ 9,截字省略号12345.hh &#123; -o-text-overflow:ellipsis;text-overflow:ellipsis;white-space:nowrapoverflow:hidden;&#125; 这个是在越出长度后会自行的截掉多出部分的文字，并以省略号结尾。技术是好技术，很多人都喜欢乱用，但注意 Firefox 并不支持","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"/tags/html/"},{"name":"css","slug":"css","permalink":"/tags/css/"}]},{"title":"js简单了解上下文","slug":"js简单了解上下文","date":"2017-02-02T16:00:00.000Z","updated":"2017-08-27T07:22:19.732Z","comments":true,"path":"2017/02/03/js简单了解上下文/","link":"","permalink":"/2017/02/03/js简单了解上下文/","excerpt":"","text":"定义 在JavaScript中，你的代码将总是有着某种形式的上下文(代码在其内部工作的 对象)。这也是其它面向对象语言所共有的功能，但它们都不如JavaScript处理得这样极端。上下文是通过变量this工作。变量this总是引用代 码当前所在的那个对象。记住全局对象实际上是window对象的属性。这意味着即使是在全局上下文里，this 变量仍然引用一个对象。上下文可以成为一个强大的工具，是面向对象代码不可或缺的一环。程序1展示了一些关于上下文的简单例子。12345678910111213141516171819202122代码 var obj = &#123; yes: function ()&#123; // this == obj this .val = true ; &#125;, no: function ()&#123; this .val = false ; &#125; &#125;; // 我们看到，obj对象没有\"val\"的属性 alert( obj.val == null ); // 我们运行yes函数，它将改变附着在obj 对象的val属性 obj.yes(); alert( obj.val == true ); // 然而，我们现在让window.no指向obj.no方法，并运行之 window.no = obj.no; window.no(); // 这导致obj对象保持不变(上下文则切换到了window对象)， alert( obj.val == true ); // 而window的val属性被更新 alert( window.val == false );","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"js变量提升和函数提升","slug":"js变量和函数的提升","date":"2017-01-31T16:00:00.000Z","updated":"2017-08-25T13:04:40.084Z","comments":true,"path":"2017/02/01/js变量和函数的提升/","link":"","permalink":"/2017/02/01/js变量和函数的提升/","excerpt":"","text":"一、先抛出一个笔试题目123456789101112var a = 100;function fn() &#123; alert(a);//undefined var a = 200; alert(a);//200&#125;fn();alert(a);//100var a;alert(a);//100var a = 300;alert(a);//300 知识点1 变量的提升 上面的代码实际的执行顺序如下12345678910111213var a;//全局作用域范围内，此时只是声明，并没有赋值a = 100;function fn()&#123; var a; alert(a);//undefined a = 200; alert(a);//200&#125;fn();alert(a);//100alert(a);//100a = 300;alert(a);//300 知识点2 函数的提升 js中创建函数有两种方式：函数声明式和函数字面量式。只有函数声明才存在函数提升！如: 1234console.log(f1); // function f1() &#123;&#125; console.log(f2); // undefined function f1() &#123;&#125;var f2 = function() &#123;&#125; 只所以会有以上的打印结果，是由于js中的函数提升导致代码实际上是按照以下来执行的：1234function f1() &#123;&#125; // 函数提升，整个代码块提升到文件的最开始console.log(f1); console.log(f2); var f2 = function() &#123;&#125; 结语：基本上就是这样，要熟练掌握的话可以多做些练习，test:1234console.log(f1); console.log(f2); function f1() &#123;console.log('aa')&#125;var f2 = function() &#123;&#125; 123456(function() &#123; console.log(a);//undefined a = 'aaa'; var a = 'bbb'; console.log(a);//bbb&#125;)();","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"js变量的只声明不赋值","slug":"js变量的只声明不赋值","date":"2017-01-29T16:00:00.000Z","updated":"2017-08-25T13:03:19.885Z","comments":true,"path":"2017/01/30/js变量的只声明不赋值/","link":"","permalink":"/2017/01/30/js变量的只声明不赋值/","excerpt":"","text":"先抛出一个两个例子12345678 function box(obj)&#123; var obj;// obj = &#123;name:122&#125; console.log(obj);&#125;var obj = new Object(&#123;name:1&#125;);box(obj);console.log(obj.name); 传参相当于在实际执行的时候执行了 this.obj = obj 12345678910function box() &#123; var obj; // obj = &#123;name:122&#125; console.log(obj);//undefined&#125;var obj = new Object(&#123; name: 1&#125;);box(obj);console.log(obj.name); 所以第二个自己是undefined","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"Ajax和Flash优缺点","slug":"Ajax和Flash的优缺点","date":"2017-01-21T16:00:00.000Z","updated":"2017-08-26T09:49:35.000Z","comments":true,"path":"2017/01/22/Ajax和Flash的优缺点/","link":"","permalink":"/2017/01/22/Ajax和Flash的优缺点/","excerpt":"","text":"Ajax优势 可搜索性 普通的文本网页会更有利于SEO。文本内容是搜索引擎容易检索的，而繁琐的swf字节码却是搜索引擎不愿触及的。虽然Google等一些大型的搜索引擎可以检索SWF内部的内容，但是仍然有很多麻烦存在。 开放性 Flash常年以来被Macromedia看的很死。包括Flex、FMS等辅佐技术一直都需要昂贵的安装、维护费用。而JS则没有这样的麻烦。没有人愿意承担法律和版权的风险。 费用 Flash开发是很昂贵的，因为FlashIDE等环境都是要收费的．而Ajax则不同．虽然有一些便宜的生成swf的工具，但是他们的工能实在无法满足复杂需求。 易用性 Ajax程序有更好的易用性。由于中间有一层Flashplayer代理层，因此许多辅助功能无法被Flash灵活利用。而且Flash在一些方面有着不好的口碑。比如弹出广告、比如恶意代码。 易于开发 人们开发复杂的Ajax和Flash应用程序时，都会借助一些高级的开发工具。普遍来说，Ajax的开发包比Flash简便、容易 Flash优势 多媒体处理 Flash在音频、视频等多媒体领域相比HTML有绝对的优势。现在几乎所有的网站都包含有Flash内容。 兼容性 兼容性好：由于通过了唯一的FlashPlayer“代理”。人们不必像调试JS那样，在不同的浏览器中调试程序。 矢量图形 这是Flash最大的优势，同样处在这一领域的SVG、Canvas element以及Direct完全不能与Flash相比。 客户端资源调度 Flash能够更容易的调用浏览器以外的外部资源。比如摄像头、麦克风等。然而这是普通的HTML无法完成的。 Ajax劣势 他可能破坏浏览器的后退动能 使用动态页面很难将某个特定状态保存到收藏夹 不过这些都有方法解决 false劣势 二进制格式 格式私有 flash文件经常会很大，用户第一次使用时要等待很久 性能问题 解决ajax前进后退功能我们可以利用ajax进行无刷新改变文档内容，但是没办法去修改URL，即无法实现浏览器的前进与后退、书签的收藏功能。 利用location的hash部分和使用window.onhashchange来实现 hash就是uri中#及后面的部分，例如：www.google.com.hk#123的#123。当只有hash部分发生变化时，浏览器的历史记录会产生记录，但不会向服务器发出请求，这时按后退键地址栏的uri会变化但页面内容不变。 通过window.onhashchange事件来监听hash值的更改。 ie6、7均不支持onhashchange，但可以用setInterval定期检查hash的改变，或者onload中检查的方法 而这样的方式对搜索引擎是十分不友好的，twitter和google约定使用hash bang (#!xxx)，也就是hash后面的第一个字符为感叹号，这样的网址他们是会爬取的，但是其他搜索引擎不支持html5的history在HTML4，Histroy对象有下面属性方法： length：历史堆栈中的记录数。 back()：返回上一页。 forward()：前进到下一页。 go([delta])：delta是个数字，如果不写或为0，则刷新本页；如果为正数，则前进到相应数目的页面；若为负数，则后退到相应数目的页面。 在HTML5中，新增了两个方法和一个事件： pushState history.pushState(stateObject, title, url)，包括三个参数。 第一个参数用于存储该url对应的状态对象，该对象可在onpopstate事件对象（event.state）中获取，也可在history对象（history.state）中获取。 第二个参数是标题，目前浏览器并未实现。 第三个参数则是设定的url。一般设置为相对路径，如果设置为绝对路径时需要保证同源。 pushState函数向浏览器的历史堆栈压入一个url为设定值的记录，并改变历史堆栈的当前指针至栈顶。 replaceState 该接口与pushState参数相同，含义也相同。唯一的区别在于replaceState是替换浏览器历史堆栈的当前历史记录为设定的url。需要注意的是，replaceState不会改动浏览器历史堆栈的当前指针。 onpopstate 该事件是window的属性。该事件会在调用浏览器的前进、后退以及执行history.forward、history.back、和history.Go触发，因为这些操作有一个共性，即修改了历史堆栈的当前指针。在不改变document的前提下，一旦当前指针改变则会触发onpopstate事件。 popstate事件对象(event)的state属性包含了这个历史记录条目的state对象的一个拷贝.12345678910window.onpopstate = function(event) &#123; alert(\"location: \" + document.location + \", state: \" + JSON.stringify(event.state));&#125;;//绑定事件处理函数. history.pushState(&#123;page: 1&#125;, \"title 1\", \"?page=1\"); //添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1history.pushState(&#123;page: 2&#125;, \"title 2\", \"?page=2\"); //添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2history.replaceState(&#123;page: 3&#125;, \"title 3\", \"?page=3\"); //修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3history.back(); // 弹出 \"location: http://example.com/example.html?page=1, state: &#123;\"page\":1&#125;\"history.back(); // 弹出 \"location: http://example.com/example.html, state: nullhistory.go(2); // 弹出 \"location: http://example.com/example.html?page=3, state: &#123;\"page\":3&#125; 具体场景实用解析http://www.cnblogs.com/accordion/p/5699372.html#top","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"/tags/html/"},{"name":"css","slug":"css","permalink":"/tags/css/"},{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"js存储","slug":"js存储","date":"2017-01-17T16:00:00.000Z","updated":"2017-08-27T07:26:55.000Z","comments":true,"path":"2017/01/18/js存储/","link":"","permalink":"/2017/01/18/js存储/","excerpt":"","text":"1. indexDBindexDB 是HTML5的本地存储，把一些数据存储到浏览器（客户端）中，当与网络断开时，可以从浏览器中读取数据，用来做一些离线应用。索引数据库 (IndexedDB) API（作为 HTML5 的一部分）对创建具有丰富本地存储数据的数据密集型的离线 HTML5 Web 应用程序很有用。同时它还有助于本地缓存数据，使传统在线 Web 应用程序（比如移动 Web 应用程序）能够更快地运行和响应。 1.http://www.cnblogs.com/dolphinX/p/3415761.html 2.http://www.cnblogs.com/dolphinX/p/3416889.html 2. cookiecookie 通过在（客户端）浏览器记录信息确定身份，最大为4kb 3. url参数url参数用的是get方法，从服务器上获取数据，大小不能大于2kb 4. sessionsession 是服务器端使用的一种记录客户端状态的机制 5. postpost 是向服务器传送数据，数据量较大 6.localStoragelocalStorage也是html5的本地存储，将数据保存在客户端，以键值对(Key-Value)的方式存储，永久存储，永不失效，除非手动删除。 大小：每个域名5M 浏览器支持：检测方法：12345if(window.localStorage)&#123; alert('This browser supports localStorage');&#125;else&#123; alert('This browser does NOT support localStorage');&#125; 常用的API： getItem //取记录 setIten//设置记录 removeItem//移除记录 key//取key所对应的值 clear//清除记录 存储的内容： 数组，图片，json，样式，脚本。。。（只要是能序列化成字符串的内容都可以存储） 7. sessionStorageHTML5 的本地存储 API 中的 localStorage 与 sessionStorage 在使用方法上是相同的，区别在于 sessionStorage 在关闭页面后即被清空，而 localStorage 则会一直保存。 7. userData对于IE浏览器有UserData，大小是64k,只有IE浏览器支持。UserData是微软为IE专门在系统中开辟的一块存储空间，所以说只支持Windows+IE的组合，实际测试在2000（IE5.5）、XP（IE6、IE7），Vista（IE7）下都是可以正常使用的。","categories":[{"name":"js","slug":"js","permalink":"/categories/js/"}],"tags":[{"name":"存储","slug":"存储","permalink":"/tags/存储/"}]},{"title":"js作用域和作用域链","slug":"js作用域和作用域链","date":"2017-01-12T16:00:00.000Z","updated":"2017-08-25T13:05:59.947Z","comments":true,"path":"2017/01/13/js作用域和作用域链/","link":"","permalink":"/2017/01/13/js作用域和作用域链/","excerpt":"","text":"一、先抛出一个笔试题目123456789101112var a = 100; function fn() &#123; alert(a);//undefined var a = 200; alert(a);//200 &#125; fn(); alert(a);//100 var a; alert(a);//100 var a = 300; alert(a);//300 知识点1 变量的提升 上面的代码实际的执行顺序如下12345678910111213var a;//全局作用域范围内，此时只是声明，并没有赋值a = 100;function fn()&#123; var a; alert(a);//undefined a = 200; alert(a);//200&#125;fn();alert(a);//100alert(a);//100a = 300;alert(a);//300 知识点2 函数的提升 js中创建函数有两种方式：函数声明式和函数字面量式。只有函数声明才存在函数提升！如:1234console.log(f1); // function f1() &#123;&#125; console.log(f2); // undefined function f1() &#123;&#125;var f2 = function() &#123;&#125; 只所以会有以上的打印结果，是由于js中的函数提升导致代码实际上是按照以下来执行的：1234function f1() &#123;&#125; // 函数提升，整个代码块提升到文件的最开始console.log(f1); console.log(f2); var f2 = function() &#123;&#125; 结语：基本上就是这样，要熟练掌握的话可以多做些练习，test:1234console.log(f1); console.log(f2); function f1() &#123;console.log('aa')&#125;var f2 = function() &#123;&#125; 123456(function() &#123; console.log(a);//undefined a = 'aaa'; var a = 'bbb'; console.log(a);//bbb&#125;)();","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"js你说不知道的编译","slug":"js你所不知道的预编译","date":"2016-12-28T16:00:00.000Z","updated":"2017-08-25T13:07:41.708Z","comments":true,"path":"2016/12/29/js你所不知道的预编译/","link":"","permalink":"/2016/12/29/js你所不知道的预编译/","excerpt":"","text":"JavaScript三部曲前言 在JavaScript中变量和函数的声明会提升到最顶部执行。 函数的提升高于变量的提升。 函数内部如果用var声明了相同名称的外部变量，函数将不再向上寻找。 匿名函数不会提升。 不同script脚本块中的函数互不影响。脚本执行引擎都做了什么 语法分析 预编译 解释执行 通俗讲就是 在执行代码前，还有两个步骤 语法分析很简单，就是引擎检查你的代码有没有什么低级的语法错误 解释执行顾名思义便是执行代码了 预编译简单理解就是在内存中开辟一些空间，存放一些变量与函数理解了预编译对大家理解作用域同样有帮助 JS预编译什么时候发生 我当初思维误区也发生在这里 预编译到底什么时候发生 希望大家不要让上面的运行过程让你产生误会， 误以为预编译仅仅发生在script内代码块执行前 这倒并没有错 预编译确确实实在script代码内执行前发生了 但是它大部分会发生在函数执行前JS预编译实例几个概念 变量声明 关键词var 函数声明 关键词function注意函数声明和函数表达是的区别1234567891011121314 &lt;script&gt; var a = 1;// 变量声明 function b(y)&#123;//函数声明 var x = 1; console.log('so easy'); &#125;; var c = function()&#123;//是变量声明而不是函数声明！！ //... &#125; b(100);&lt;/script&gt;&lt;script&gt; var d = 0;&lt;/script&gt; 让我们看看引擎对这段代码做了什么吧 页面产生便创建了GO全局对象（Global Object）（也就是大家熟悉的window对象） 第一个脚本文件加载 脚本加载完毕后，分析语法是否合法 开始预编译 查找变量声明，作为GO属性，值赋予undefined 查找函数声明，作为GO属性，值赋予函数体12345678910 //伪代码GO/window = &#123; //页面加载创建GO同时，创建了document、navigator、screen等等属性，此处省略 a: undefined, c: undefined， b: function(y)&#123; var x = 1; console.log('so easy'); &#125;&#125; 解释执行代码（直到执行函数b）123456789101112//伪代码GO/window = &#123; //变量随着执行流得到初始化 a: 1, c: function()&#123; //... &#125;, b: function(y)&#123; var x = 1; console.log('so easy'); &#125;&#125; 执行函数b之前，发生预编译 创建AO活动对象（Active Object） 查找形参和变量声明，值赋予undefined 实参值赋给形参 查找函数声明，值赋予函数体123456//伪代码AO = &#123; //创建AO同时，创建了arguments等等属性，此处省略 y: 100, x: undefined&#125; 解释执行函数中代码 第一个脚本文件执行完毕，加载第二个脚本文件注意每个script是独立的,不会预编译下一个scipt 第二个脚本文件加载完毕后，进行语法分析 语法分析完毕，开始预编译 重复最开始的预编译步骤…… 结语预编译阶段发生变量声明和函数声明，没有初始化行为（赋值），匿名函数不参与预编译只有在解释执行阶段才会进行变量初始化 预编译(函数执行前)※ 创建AO对象（Active Object） 查找函数形参及函数内变量声明，形参名及变量名作为AO对象的属性，值为undefined 实参形参相统一，实参值赋给形参 查找函数声明，函数名作为AO对象的属性，值为函数引用 预编译(脚本代码块script执行前) 查找全局变量声明（包括隐式全局变量声明，省略var声明），变量名作全局对象的属性，值为undefined 查找函数声明，函数名作为全局对象的属性，值为函数引用 理解了预编译对理解提升行为，this指向，作用域及性能等问题都有很大帮助","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"Node.js的学习--使用cheerio抓取网页数据","slug":"Node.js的学习--使用cheerio抓取网页数据","date":"2016-12-17T16:00:00.000Z","updated":"2017-08-25T13:06:06.592Z","comments":true,"path":"2016/12/18/Node.js的学习--使用cheerio抓取网页数据/","link":"","permalink":"/2016/12/18/Node.js的学习--使用cheerio抓取网页数据/","excerpt":"","text":"打算要写一个公开课网站，缺少数据，就决定去网易公开课去抓取一些数据。 前一阵子看过一段时间的Node.js，而且Node.js也比较适合做这个事情，就打算用Node.js去抓取数据。 关键是抓取到网页之后如何获取到想要的数据呢？然后就发现了cheerio，用来解析html非常方便，就像在浏览器中使用jquery一样。 使用如下命令安装cheerio npm install cheerio Cheerio安装完成， 我们就可以开始工作了。 首先让我们来看一段javascript代码 这段代码可以下载任意一个网页的内容。将其放入到curl.js中，并导出。12345678910111213141516171819 var http = require(\"http\"); // Utility function that downloads a URL and invokes// callback with the data.function download(url, callback) &#123; http.get(url, function(res) &#123; var data = \"\"; res.on('data', function (chunk) &#123; data += chunk; &#125;); res.on(\"end\", function() &#123; callback(data); &#125;); &#125;).on(\"error\", function() &#123; callback(null); &#125;);&#125;exports.download = download; 然后是使用cheerio解析html，找到想要的数据。 我们先来自己分析一下页面。我们要抓取http://v.163.com/special/opencourse/englishs1.html这个页面中的视频，视频的地址都在下载的按钮里。其中一个下载按钮的html的代码如下：12&lt;a class=\"downbtn\" href=\"http://mov.bn.netease.com/mobilev/2013/1/F/G/S8KTEF7FG.mp4\" id=\"M8KTEKR84\" target=\"_blank\"&gt;&lt;/a&gt; 我们取到其中的href属性，只需要进行如下选择即可12$(\"a.downbtn\").attr(\"href\"); 在是现实，我们可以在index.js中写入如下代码12345678910111213141516171819var cheerio = require(\"cheerio\");var server = require(\"./curl\"); var url = \"http://v.163.com/special/opencourse/englishs1.html\"server.download(url, function(data) &#123; if (data) &#123; //console.log(data); var $ = cheerio.load(data); $(\"a.downbtn\").each(function(i, e) &#123; console.log($(e).attr(\"href\")); &#125;); console.log(\"done\"); &#125; else &#123; console.log(\"error\"); &#125; &#125;);","categories":[{"name":"Node","slug":"Node","permalink":"/categories/Node/"},{"name":"爬虫","slug":"Node/爬虫","permalink":"/categories/Node/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"/tags/爬虫/"},{"name":"cheerio","slug":"cheerio","permalink":"/tags/cheerio/"}]},{"title":"深入理解JavaScript执行上下文、函数堆栈、提升的概念","slug":"js深入理解JavaScript执行上下文、函数堆栈、提升的概念 ","date":"2016-12-01T16:00:00.000Z","updated":"2017-08-25T12:52:13.800Z","comments":true,"path":"2016/12/02/js深入理解JavaScript执行上下文、函数堆栈、提升的概念 /","link":"","permalink":"/2016/12/02/js深入理解JavaScript执行上下文、函数堆栈、提升的概念 /","excerpt":"","text":"首先明确几个概念EC：函数执行环境（或执行上下文），Execution ContextECS：执行环境栈，Execution Context StackVO：变量对象，Variable ObjectAO：活动对象，Active Objectscope chain：作用域链 EC执行上下文每次当控制器转到ECMAScript可执行代码的时候，就会进入到一个执行上下文。那什么是可执行代码呢？ 可执行代码的类型 全局代码（Global code）这种类型的代码是在”程序”级处理的：例如加载外部的js文件或者本地”“标签内的代码。全局代码不包括任何function体内的代码。 这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。 函数代码（Function code）任何一个函数体内的代码，但是需要注意的是，具体的函数体内的代码是不包括内部函数的代码。 Eval代码（Eval code）eval内部的代码ECS（执行环境栈）我们用MDN上的一个例子来引入函数执行栈的概念12345678910111213141516function foo(i) &#123; if (i &lt; 0) return; console.log('begin:' + i); foo(i - 1); console.log('end:' + i);&#125;foo(2);// 输出:// begin:2// begin:1// begin:0// end:0// end:1// end:2 ······························转····························· 先了解一下函数执行上下文堆栈的概念浏览器中的JS解释器被实现为单线程，这也就意味着同一时间只能发生一件事情，其他的行为或事件将会被放在叫做执行栈里面排队。下面的图是单线程栈的抽象视图： 当浏览器首次载入你的脚本，它将默认进入全局执行上下文。如果，你在你的全局代码中调用一个函数，你程序的时序将进入被调用的函数，并创建一个新的执行上下文，并将新创建的上下文压入执行栈的顶部。如果你调用当前函数内部的其他函数，相同的事情会在此上演。代码的执行流程进入内部函数，创建一个新的执行上下文并把它压入执行栈的顶部。浏览器总会执行位于栈顶的执行上下文，一旦当前上下文函数执行结束，它将被从栈顶弹出，并将上下文控制权交给当前的栈。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。 VO（变量对象）/AO（活动对象）这里为什么要用一个/呢？按照字面理解，AO其实就是被激活的VO，两个其实是一个东西。 变量对象（Variable object）是说JS的执行上下文中都有个对象用来存放执行上下文中可被访问但是不能被delete的函数标示符、形参、变量声明等。它们会被挂在这个对象上，对象的属性对应它们的名字对象属性的值对应它们的值但这个对象是规范上或者说是引擎实现上的不可在JS环境中访问到活动对象 激活对象（Activation object）有了变量对象存每个上下文中的东西，但是它什么时候能被访问到呢？就是每进入一个执行上下文时，这个执行上下文儿中的变量对象就被激活，也就是该上下文中的函数标示符、形参、变量声明等就可以被访问到了 EC建立的细节 创建阶段【当函数被调用，但未执行任何其内部代码之前】 创建作用域链（Scope Chain） 创建变量，函数和参数。 求”this“的值 执行阶段初始化变量的值和函数的引用，解释/执行代码。我们可以将每个执行上下文抽象为一个对象，这个对象具有三个属性ECObj: { scopeChain: { / 变量对象（variableObject）+ 所有父级执行上下文的变量对象/ }, variableObject: { /函数 arguments/参数，内部变量和函数声明 / }, this: {}} 解释器执行代码的伪逻辑 查找调用函数的代码。 执行代码之前，先进入创建上下文阶段： 初始化作用域链 创建变量对象： 创建arguments对象，检查上下文，初始化参数名称和值并创建引用的复制。 扫描上下文的函数声明（而非函数表达式）： 为发现的每一个函数，在变量对象上创建一个属性——确切的说是函数的名字——其有一个指向函数在内存中的引用。 如果函数的名字已经存在，引用指针将被重写。 扫描上下文的变量声明： 为发现的每个变量声明，在变量对象上创建一个属性——就是变量的名字，并且将变量的值初始化为undefined 如果变量的名字已经在变量对象里存在，将不会进行任何操作并继续扫描。 求出上下文内部this的值。 激活/代码执行阶段： 在当前上下文上运行/解释函数代码，并随着代码一行行执行指派变量的值。 VO — 对应上述第二个阶段123456function foo(i)&#123; var a = 'hello' var b = function()&#123;&#125; function c()&#123;&#125;&#125;foo(22) 当我们调用foo(22)时，整个创建阶段是下面这样的1234567891011121314ECObj = &#123; scopChain： &#123;...&#125;, variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: undefined, b: undefined &#125;, this: &#123; ... &#125;&#125; 正如我们看到的，在上下文创建阶段，VO的初始化过程如下（该过程是有先后顺序的：函数的形参==&gt;&gt;函数声明==&gt;&gt;变量声明）： 函数的形参（当进入函数执行上下文时） —— 变量对象的一个属性，其属性名就是形参的名字，其值就是实参的值；对于没有传递的参数，其值为undefined 函数声明（FunctionDeclaration, FD） —— 变量对象的一个属性，其属性名和值都是函数对象创建出来的；如果变量对象已经包含了相同名字的属性，则替换它的值 变量声明（var，VariableDeclaration） —— 变量对象的一个属性，其属性名即为变量名，其值为undefined;如果变量名和已经声明的函数名或者函数的参数名相同，**则不会影响已经存在的属性。** 如何理解函数声明过程中如果变量对象已经包含了相同名字的属性，则替换它的值这句话？ 看如下这段代码：12345function foo1(a)&#123; console.log(a) function a()&#123;&#125; &#125;foo1(20)//'function a()&#123;&#125;' 根据上面的介绍，我们知道VO创建过程中，函数形参的优先级是高于函数的声明的，结果是函数体内部声明的function a(){}覆盖了函数形参a的声明，因此最后输出a是一个function 如何理解变量声明过程中如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性这句话？123456//情景一：与参数名相同function foo2(a)&#123; console.log(a) var a = 10&#125;foo2(20) //'20' 12345678//情景二：与函数名相同function foo2()&#123; console.log(a) var a = 10 function a()&#123;&#125;&#125;foo2() //'function a()&#123;&#125;' 下面是几个比较有趣的例子，当做加餐小菜，大家细细品味。这里给出一句话当做参考： 函数声明比变量优先级要高，并且定义过程不会被变量覆盖，除非是赋值 123456function foo3(a)&#123; var a = 10 function a()&#123;&#125; console.log(a)&#125;foo3(20) //'10' 123456function foo3(a)&#123; var a function a()&#123;&#125; console.log(a)&#125;foo3(20) //'function a()&#123;&#125;' 123456function foo2(a) &#123; console.log(a) var a = 10 function a() &#123;&#125;&#125;foo2(20) //'function a()&#123;&#125;' 123456function foo2(a) &#123; var a = 10 function a() &#123;&#125; console.log(a) &#125; foo2(20) //'10' 小结：&gt;函数声明的提升&gt;赋值的优先级&gt;变量的提升 函数声明（FunctionDeclaration, FD） —— 变量对象的一个属性，其属性名和值都是函数对象创建出来的；如果变量对象已经包含了相同名字的属性，则替换它的值。可以理解为声明则赋值一个指针？ 12345678function foo2(a) &#123; var a = 10 function a() &#123; // &#125; console.log(a) &#125; foo2(20) //'function a()' 变量声明（var，VariableDeclaration） —— 变量对象的一个属性，其属性名即为变量名，其值为undefined;如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性。 AO — 对应第三个阶段正如我们看到的，创建的过程仅负责处理定义属性的名字，而并不为他们指派具体的值，当然还有对形参/实参的处理。一旦创建阶段完成，执行流进入函数并且激活/代码执行阶段，看下函数执行完成后的样子：1234567891011121314 ECObj = &#123; scopeChain: &#123; ... &#125;, variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: 'hello', b: pointer to function privateB() &#125;, this: &#123; ... &#125;&#125; 提升（Hoisting）对于下面的代码，相信很多人都能一眼看出输出结果，但是却很少有人能给出为什么会产生这种输出结果的解释。12345678910111213(function() &#123; console.log(typeof foo); // 函数指针 console.log(typeof bar); // undefined var foo = 'hello', bar = function() &#123; return 'world'; &#125;; function foo() &#123; return 'hello'; &#125;&#125;()); 为什么我们能在foo声明之前访问它？回想在VO的创建阶段，我们知道函数在该阶段就已经被创建在变量对象中。所以在函数开始执行之前，foo已经被定义了。 Foo被声明了两次，为什么foo显示为函数而不是undefined或字符串？我们知道，在创建阶段，函数声明是优先于变量被创建的。而且在变量的创建过程中，如果发现VO中已经存在相同名称的属性，则不会影响已经存在的属性。因此，对foo()函数的引用首先被创建在活动对象里，并且当我们解释到var foo时，我们看见foo属性名已经存在，所以代码什么都不做并继续执行。 为什么bar的值是undefined？bar采用的是函数表达式的方式来定义的，所以bar实际上是一个变量，但变量的值是函数，并且我们知道变量在创建阶段被创建但他们被初始化为undefined，这也是为什么函数表达式不会被提升的原因。 总结： EC分为两个阶段，创建执行上下文和执行代码。 每个EC可以抽象为一个对象，这个对象具有三个属性，分别为：作用域链Scope，VO|AO（AO，VO只能有一个）以及this。 函数EC中的AO在进入函数EC时，确定了Arguments对象的属性；在执行函数EC时，其它变量属性具体化。 EC创建的过程是由先后顺序的：参数声明 &gt; 函数声明 &gt; 变量声明 12345678910function foo2(a) &#123; console.log(a)//function a() var a = 10 function a() &#123; console.log(fsdf); &#125; console.log(a)//10 console.log(a())//报错 a is not a function &#125; foo2(20) 解释：提升的过程函数声明的优先级比形参和变量高，后面的执行代码的阶段赋值行为是在最后面,因此打印10，最后的console会报错","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"mongodb mongoose node中间件增删改查方法","slug":"mongose中间件","date":"2016-11-27T16:00:00.000Z","updated":"2017-08-25T13:29:10.350Z","comments":true,"path":"2016/11/28/mongose中间件/","link":"","permalink":"/2016/11/28/mongose中间件/","excerpt":"","text":"官网 http://mongoosejs.com/docs/api.html#model_Model.update 命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344#model.js$whereincrementmodelModelremovesaveaggregatebulkWritecountcreatedeleteManydeleteOnediscriminatordistinctensureIndexesfindfindByIdfindByIdAndRemovefindByIdAndUpdatefindOnefindOneAndRemovefindOneAndUpdategeoNeargeoSearchhydrateinsertManymapReducepopulateremovereplaceOnetranslateAliasesupdateupdateManyupdateOnewhere$wherebasebaseModelNamecollectiondbdiscriminatorsmodelNameschema","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"/tags/mongodb/"}]},{"title":"Vue 生命周期","slug":"vue.生命周期","date":"2016-11-14T16:00:00.000Z","updated":"2017-08-25T13:30:22.000Z","comments":true,"path":"2016/11/15/vue.生命周期/","link":"","permalink":"/2016/11/15/vue.生命周期/","excerpt":"","text":"前言 在使用vue一个多礼拜后，感觉现在还停留在初级阶段，虽然知道怎么和后端做数据交互，但是对于mounted这个挂载还不是很清楚的。放大之，对vue的生命周期不甚了解。只知道简单的使用，而不知道为什么，这对后面的踩坑是相当不利的。 因为我们有时候会在几个钩子函数里做一些事情，什么时候做，在哪个函数里做，我们不清楚。 vue生命周期简介 生命周期探究&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/vue/2.1.3/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var app = new Vue(&#123; el: '#app', data: &#123; message : \"xuxiao is boy\" &#125;, beforeCreate: function () &#123; console.group('beforeCreate 创建前状态===============》'); console.log(\"%c%s\", \"color:red\" , \"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //undefined console.log(\"%c%s\", \"color:red\",\"message: \" + this.message) &#125;, created: function () &#123; console.group('created 创建完毕状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 &#125;, beforeMount: function () &#123; console.group('beforeMount 挂载前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + (this.$el)); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 &#125;, mounted: function () &#123; console.group('mounted 挂载结束状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 &#125;, beforeUpdate: function () &#123; console.group('beforeUpdate 更新前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); &#125;, updated: function () &#123; console.group('updated 更新完成状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); &#125;, beforeDestroy: function () &#123; console.group('beforeDestroy 销毁前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); create 和 mounted 相关 beforecreated：el 和 data 并未初始化created:完成了 data 数据的初始化，el没有beforeMount：完成了 el 和 data 初始化mounted ：完成挂载 生命周期总结 beforecreate : 举个栗子：可以在这加个loading事件created ：在这结束loading，还做一些初始化，实现函数自执行mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情beforeDestory： 你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容 参考文献 https://segmentfault.com/q/10… http://www.cnblogs.com/gagag/…","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"}]},{"title":"Vue loading加载动画组件","slug":"vue loading组件","date":"2016-11-01T16:00:00.000Z","updated":"2017-08-25T13:29:09.036Z","comments":true,"path":"2016/11/02/vue loading组件/","link":"","permalink":"/2016/11/02/vue loading组件/","excerpt":"","text":"实现效果实现了加载是颜色的变化以及进度条的变化 下面是代码实现 html页面测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style&gt; .spinner &#123; transform-origin: center; animation: rotator 6s linear infinite; background-color:#cccccc; width:150px; height:150px; &#125; @keyframes rotator &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(270deg); &#125; &#125; .path &#123; stroke-dasharray: 187; stroke-dashoffset: 0; transform-origin: center; animation: dash 2s ease-in-out infinite, colors 4s ease-in-out infinite; &#125; @keyframes colors &#123; 0% &#123; stroke: #4285F4; &#125; 25% &#123; stroke: #DE3E35; &#125; 50% &#123; stroke: #F7C223; &#125; 75% &#123; stroke: #1B9A59; &#125; 100% &#123; stroke: #4285F4; &#125; &#125; @keyframes dash &#123; 0% &#123; stroke-dashoffset: 187; &#125; 50% &#123; stroke-dashoffset: 93.5; &#125; 100% &#123; stroke-dashoffset: 0; &#125; &#125;&lt;/style&gt;&lt;body&gt; &lt;svg class=\"spinner\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;circle class=\"path\" stroke=\"red\" fill=\"none\" stroke-width=\"6\" cx=\"75\" cy=\"75\" r=\"30\"&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/body&gt;&lt;/html&gt; vue Loading组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;template&gt; &lt;div class=\"loading-component\"&gt; &lt;svg class=\"spinner\" :style=\"loadingSize\" viewBox=\"0 0 66 66\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;circle class=\"path\" :style=\"loadingColor\" fill=\"none\" :stroke-width=\"stroke\" cx=\"33\" cy=\"33\" r=\"30\"&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=\"text/ecmascript-6\"&gt; export default &#123; props: &#123; size: &#123; type: Number, default: 50 &#125;, stroke: &#123; type: Number, default: 3.5 &#125;, color: &#123; type: String, default: '#ed424b' &#125; &#125;, computed: &#123; loadingSize() &#123; const newSize = this.size + 'px' return &#123; width: newSize, height: newSize &#125; &#125;, loadingColor() &#123; return &#123; stroke: this.color &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=\"less\" type=\"text/less\"&gt; .loading-component &#123; display: inline-block; pointer-events: none; will-change: transform, opacity; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); &#125; //2 * pi * r = 188.4 @offset: 187; @duration: 1.4s; //设置外层旋转形成加载的效果 .spinner &#123; transform-origin: center; animation: rotator @duration linear infinite; &#125; @keyframes rotator &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(270deg); &#125; &#125; .path &#123; stroke-dasharray: @offset; stroke-dashoffset: 0; transform-origin: center; // 设置颜色变化以及dash长度的变化 animation: dash @duration ease-in-out infinite, colors @duration ease-in-out infinite; &#125; @keyframes colors &#123; 0% &#123; stroke: #4285F4; &#125; 25% &#123; stroke: #DE3E35; &#125; 50% &#123; stroke: #F7C223; &#125; 75% &#123; stroke: #1B9A59; &#125; 100% &#123; stroke: #4285F4; &#125; &#125; //让空白部分慢慢减少 @keyframes dash &#123; 0% &#123; stroke-dashoffset: @offset; &#125; 50% &#123; stroke-dashoffset: @offset/4; &#125; 100% &#123; stroke-dashoffset: @offset; &#125; &#125;&lt;/style&gt;","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"}]},{"title":"v-model本质（以底部导航切换为例子）","slug":"v-model","date":"2016-10-24T16:00:00.000Z","updated":"2017-08-25T13:29:10.021Z","comments":true,"path":"2016/10/25/v-model/","link":"","permalink":"/2016/10/25/v-model/","excerpt":"","text":"v-modelv-model本质是1&lt;input type=\"text\" v-bind:value=\"dataA\" v-on:input=\"dataA = $event.target.value\" /&gt; 1.Index页面该页面包含了m-tabbar和m-tabbar-item组件，目的是实现底部tab切换m-tabbar传入 v-mode:”select”实际上是v-bind:value=”select” v-on:input=”select = $event.target.value”v-bind:value=”select”传入的props(父-&gt;子)v-on:input=”select = $event.target.value” 监听$emit(‘input’,…)v-model 数据双向绑定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div&gt; &lt;m-tabbar v-model=\"select\"&gt; &lt;m-tabbar-item id='tab1'&gt; &lt;img src=\"../assets/images/ic_tab_home_normal.png\" alt=\"\" slot=\"icon-normal\"&gt; &lt;img src=\"../assets/images/ic_tab_home_active.png\" alt=\"\" slot=\"icon-active\"&gt; 首页 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id='tab2'&gt; &lt;img src=\"../assets/images/ic_tab_subject_normal.png\" alt=\"\" slot=\"icon-normal\"&gt; &lt;img src=\"../assets/images/ic_tab_subject_active.png\" alt=\"\" slot=\"icon-active\"&gt; 书影音 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id='tab3'&gt; &lt;img src=\"../assets/images/ic_tab_status_normal.png\" alt=\"\" slot=\"icon-normal\"&gt; &lt;img src=\"../assets/images/ic_tab_status_active.png\" alt=\"\" slot=\"icon-active\"&gt; 广播 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id='tab4'&gt; &lt;img src=\"../assets/images/ic_tab_group_normal.png\" alt=\"\" slot=\"icon-normal\"&gt; &lt;img src=\"../assets/images/ic_tab_group_active.png\" alt=\"\" slot=\"icon-active\"&gt; 小组 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id='tab5'&gt; &lt;img src=\"../assets/images/ic_tab_profile_normal.png\" alt=\"\" slot=\"icon-normal\"&gt; &lt;img src=\"../assets/images/ic_tab_profile_active.png\" alt=\"\" slot=\"icon-active\"&gt; 我的 &lt;/m-tabbar-item&gt; &lt;/m-tabbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import mTabbar from '../components/tabbar' import mTabbarItem from '../components/tabbar-item' export default &#123; name: 'index', components: &#123; mTabbar, mTabbarItem &#125;, data()&#123; return&#123; select:'tab1' &#125; &#125;, watch:&#123; select:function()&#123; console.log(this.select); &#125; &#125; &#125;&lt;/script&gt; 1.父组件接收v-bind:value属性123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=\"m-tabbar\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:['value']&#125;&lt;/script&gt;&lt;style lang=\"less\"&gt;.m-tabbar&#123; display: flex; flex-direction: row; position: fixed; bottom: 0; left: 0; right: 0; width: 100%; overflow: hidden; height: 50px; background: #fff; border-top: 1px solid #e4e4e4;&#125;&lt;/style&gt; 2.子组件接收id属性值，通过$parent.$emit(‘input’,id)向父组件传递当前点击id的值，父组件由on来接收123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;a class=\"m-tabbar-item\" :class=\"&#123;'is-active':isActive&#125;\" @click=\"$parent.$emit('input',id)\"&gt; &lt;span class=\"m-tabbar-item-icon\" v-show=\"!isActive\"&gt;&lt;slot name=\"icon-normal\"&gt;&lt;/slot&gt;&lt;/span&gt; &lt;span class=\"m-tabbar-item-icon\" v-show=\"isActive\"&gt;&lt;slot name=\"icon-active\"&gt;&lt;/slot&gt;&lt;/span&gt; &lt;span class=\"m-tabbar-item-text\"&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/span&gt; &lt;/a&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:['id'], computed: &#123; isActive()&#123; if(this.$parent.value===this.id)&#123; return true; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"less\"&gt;.m-tabbar-item&#123; flex: 1; text-align: center; .m-tabbar-item-icon&#123; display: block; padding-top: 2px; img&#123; width: 28px; height: 28px; &#125; &#125; .m-tabbar-item-text&#123; display: block; font-size: 10px; color:#949494; &#125; &amp;.is-active&#123; .m-tabbar-item-text&#123; color: #42bd56; &#125; &#125;&#125;&lt;/style&gt;","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"}]},{"title":"IIS部署","slug":"iis部署","date":"2016-10-02T16:00:00.000Z","updated":"2017-08-25T12:51:31.140Z","comments":true,"path":"2016/10/03/iis部署/","link":"","permalink":"/2016/10/03/iis部署/","excerpt":"","text":"IIS名词介绍1.IIS简介 Internet Information Service 微软服务器，windows系统都自带这个功能 2.互联网相关名词介绍 服务器Server;通常是指服务器硬件。还有服务器软件（程序） 服务器软件是运行在电脑上的程序，电脑也可以当做一个服务器 URL：统一资源定位符 https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1492594445597&amp;di=1b28e8ff63505088aff8a1f3567bd44e&amp;imgtype=0&amp;src=http%3A%2F%2Fmvimg2.meitudata.com%2F55713dd0165c89055.jpg 域名domain name address: www.baidu.com ip地址：命令提示符 –&gt; ipconfig 使用ping www.baidu.com可以把域名转换成ip地址 DNS： Domain name system域名解析服务 开启IIS服务器123456789101112* 1.打开控制面板--&gt;程序--&gt;启用或关闭windows功能--&gt;internet information service--&gt;全部勾选* 2.使用localhost或者127.0.0.1访问本地服务器* 3.默认站点，IIS服务器默认站点在c:\\inetpub\\wwwroot文件夹下* 4.默认文档，打开服务器的时候加载显示的页面。可以上移提高优先级，也可以添加自己想要显示的页面。* 5.注意浏览器缓存，可能会加载以前缓存的页面，而没有加载自己添加的页面* 6.目录浏览，把服务器下的文件以目录的形式展示，这种方式很不安全，因为会把所有文件暴露出来* 7.开启目录浏览，需要把默认文档关掉或者删除所有的默认文档* 8.如果被人通过ip地址访问你的电脑。需要把防火墙关闭* 9.添加站点，端口需要改，要指定路径，如果不能访问，没有权限，需要修改权限* 10.文件夹--&gt;右键属性--&gt;安全--&gt;编辑--&gt;添加--&gt;everyone--&gt;全部控制--&gt;应用* 11.ftp文件传输协议，上传下载文件* 12.http超文本传输协议","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"代理","slug":"代理","permalink":"/tags/代理/"}]},{"title":"深入理解HTTP协议（转）","slug":"深入理解HTTP协议（转）","date":"2016-09-20T16:00:00.000Z","updated":"2017-08-25T11:21:24.000Z","comments":true,"path":"2016/09/21/深入理解HTTP协议（转）/","link":"","permalink":"/2016/09/21/深入理解HTTP协议（转）/","excerpt":"","text":"从浏览器地址栏输入url到显示页面的步骤(以HTTP为例) 在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树： Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树: 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 js解析如下： 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件 显示页面（HTML解析过程中会逐步显示页面）","categories":[{"name":"Http","slug":"Http","permalink":"/categories/Http/"}],"tags":[{"name":"页面请求","slug":"页面请求","permalink":"/tags/页面请求/"}]},{"title":"SUPERAGENT","slug":"批处理HTTP模块SuperAgent","date":"2016-09-09T16:00:00.000Z","updated":"2017-08-25T12:49:20.651Z","comments":true,"path":"2016/09/10/批处理HTTP模块SuperAgent/","link":"","permalink":"/2016/09/10/批处理HTTP模块SuperAgent/","excerpt":"","text":"最近在写爬虫，看了下node里面有啥关于ajax的模块,发现superagent这个模块灰常的好用。好东西要和大家分享，话不多说，开始吧～ 什么是SuperAgentsuperagent它是一个强大并且可读性很好的轻量级ajaxAPI，是一个关于HTTP方面的一个库，而且它可以将链式写法玩的出神入化。1var superagent = require('superagent'); superagent .post('/api') .send(&#123; 'key': 'value' &#125;) .set('header_key', 'header_value') .end(function(err, res) &#123; if (err) &#123; //do something &#125; else &#123; //do something &#125; &#125;) 接下来，让我们逐一的对SuperAgent的一些特性进行分析吧～🚀 设置请求头 这一点在写爬虫的时候十分的有用,因为有些网站可能设置了一些限制条件,比如它会去匹配你的请求头里面的一些字段, 像User-Agent Referer等,如果你没有设置这些请求头的话，可能就抓取不到数据咯～ SuperAgent里面设置请求头很简单,通过使用set()方法就可以设置了，有两种方式 单个单个的设置 1234567891011121314151617181920superagent .get('/api') .set('Referer','https://www.google.com') .set('Accept','image/webp,image/*,*/*;q=0.8') .end(function(req,res)&#123; //do something &#125;) 放在一起设置 superagent .get('/api') .set(&#123; 'Referer','https://www.google.com', 'Accept','image/webp,image/*,*/*;q=0.8' &#125;) .end(function(req,res)&#123; //do something &#125;) GET请求方式 我相信大家都一定见过这样类型的URL:http://localhost:8080/api和http://localhost:8080/api?id=1&amp;price=10,就是GET方式可以带上参数,也可以不带上参数。不带参数的就不说了,相信大家都会,在superagent中我们可以通过query()方法给URL后面带上参数,有4种写法 12345678910111213141516171819202122232425//接下来所形成的URL为/api?name=An&amp;age=20&amp;sex=male//第一种superagent .get(/api) .query(&#123;name:'An'&#125;) .query(&#123;age:20&#125;) .query(&#123;sex:'male'&#125;) .end(cb)//第二种superagent .get(/api) .query(&#123;name:'An',age:20,sex:'male'&#125;) .end(cb)//第三种 superagent .get(/api) .query('name=An&amp;age=20&amp;sex=male') .end(cb)//第四种 superagent .get(/api) .query('name=An') .query('age=20') .query('sex=male') .end(cb) head请求 head请求也可以通过query()的方式进行传递参数,大家可以参考👆的GET请求 POST/PUT请求 这两种请求，一般是要给服务端发送数据，现在文本数据的方式一般都以json的方式传递。我们可以在请求头里设置Accept=application/json，从而服务器可以根据请求头来生成json数据(在java开发后台时可以这样) 在superagent里面，默认的数据传递格式是json，所以下面几种种方式是相同的。 1234567891011121314151617superagent .post('/api') .set('Accept','application/json') .send('&#123;\"name\":\"An\",\"age\":20,\"sex\":\"male\"&#125;') .end(cb)//等价于 ==&gt;superagent .post('/api') .send(&#123;name:\"An\",age:20,sex:\"male\"&#125;) .end(cb)//等价于 ==&gt;superagent .post('/api') .send(&#123;name:\"An\"&#125;) .send(&#123;age:20&#125;) .sex(&#123;sex:'male'&#125;) .end(cb) 当然，除了json的形式去传递，我们还有一种很常见的表单提交，在superagent里，也实现了模拟表单的提交数据类型application/x-www-form-urlencoded， 我们可以通过type(&apos;form&apos;)方法进行转换 12345superagent .post('/api') .type('form') .send(&#123;name:'An',age:20&#125;) // name=An&amp;age=20 .end(cb) 有时候，我们也会在POST请求时，将一些参数放在URL上面，那这个时候还是可以用query()方法 设置Content-Type的两种快速方式 type()方法 accept()方法 这两种方法都可以接受规范的MIME格式,以及图片和xml等这些格式的数据。 123456789101112superagent .post('/api') .type('application/json') .type('png')// 等价于==&gt;superagent .post('/api') .accept('application/json') .accept('png') 分析处理response body superagent可以帮你解析返回的数据,当前支持三种类型的数据application/x-www-form-urlencoded application/json 和multipart/form-data JSON/Urlencoded 解析后的数据会以对象的形式存在,可以通过res.body来得到。 &apos;{&quot;name&quot;:&quot;An&quot;}&apos; //JSON String //解析 ==&gt; { name:&quot;An&quot; //JSON Object } Multipart 这种格式的数据的处理，superagent是通过Formidable模块，它是主要处理文件上传的模块，大家可以去了解下，也是Node里面十分常用的模块，也很简单易上手。上传的文件的信息可以在res.files去查看，当然，我觉得这个属性用的比较少，这只是个人观点了～ Response的属性 res.text包含为被解析的响应数据 res.body上文提到了，包含解析的数据，但是目前只支持三种格式 res.header响应头,是一个Object res.type &amp; res.charset 类型和编码格式 res.status状态码 终止请求 req.abort() 暂停请求 req.timeout(ms) ms表示毫秒为单位的时间 Basic Access Authentication 首先先简单的介绍下Basic Access Authenication，它是在web应用中，通过直接提供用户名、密码来进行验证身份的一种优化的解决方案。 原理是将用户名和密码通过:连接,形成username:password然后再进行base64加密，发送到服务器后再进行解密得到用户名和密码,进行进一步的匹配验证。参考文章:HTTP Basic Authentication认证。 在superagent里，有两种方式进行验证 12345678superagent .get('http://username:password@localhost') .end(cb)//等价于 ==&gt;superagent .get('http://localhost') .auth('username','password') .end(cb) 可以通过pipe管道流入流出数据 我想大家应该知道node里面有个核心特性就是stream，如果不知道的，可以参考:nodejs中流(stream)的理解,举两个栗子： 1234567891011121314//第一个例子var fs = require('fs');var request = require('superagent');var postJson = fs.createReadStream('./postDataJson');var req= request.post('/api');req.accept('json');stream.pipe(req);//第二个例子var fs = require('fs');var request = require('superagent');var getData = fs.createWriteStream('./getData');var res= request.get('/api');res.pipe(getData); 添加多个附件 superagent也提供了一些高级的API，如果你想添加多个附件可以使用attach(name,[path],[filename]),其中你可以通过filename来自定义上传后文件的文件名 12345request .post('/upload') .attach('avator','/path/a.png','An.png') .attach('photo','/path/b.png') .end(cb) 复合请求 superagent也支持复合请求,比如你想上传一个带有你的姓名和邮箱的图片，那可以通过field(name,value)方法 123456request .post('/upload') .field('name','An') .field('age':20) .attach('avator','/path/a.png','An.png') .end(cb) 错误处理 有时候我们可能会因为不同的原因得到4XX或者5XX的错误，这个时候我们确实是可以从end(function(err,res){...})里的err得到错误信息,比如er.status错误的状态码啥的，但是有些时候我们想去处理这些错误，重新发送一个别的请求啥的，那么这个时候我们可以通过on(&apos;error&apos;,handleFn)去处理了 12345request .post('/api') .send(data) .on('error',handleFn) .end(cb);","categories":[{"name":"Node","slug":"Node","permalink":"/categories/Node/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"/tags/中间件/"},{"name":"http请求","slug":"http请求","permalink":"/tags/http请求/"}]},{"title":"懒加载原理","slug":"懒加载","date":"2016-09-04T16:00:00.000Z","updated":"2017-08-25T12:49:14.448Z","comments":true,"path":"2016/09/05/懒加载/","link":"","permalink":"/2016/09/05/懒加载/","excerpt":"","text":"懒加载的原理 原理：先将img标签中的src链接设为同一张图片（空白图片），将其真正的图片地址存储再img标签的自定义属性中（比如data-src）。当js监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到src属性中，达到懒加载的效果。 这样做能防止页面一次性向服务器响应大量请求导致服务器响应慢，页面卡顿或崩溃等问题。 代码实现 既然懒加载的原理是基于判断元素是否出现在窗口可视范围内，首先我们写一个函数判断元素是否出现在可视范围内： 12345678910function isVisible($node)&#123; var winH = $(window).height(), scrollTop = $(window).scrollTop(), offSetTop = $(window).offSet().top; if (offSetTop &lt; winH + scrollTop) &#123; return true; &#125; else &#123; return false; &#125;&#125; 再添加上浏览器的事件监听函数，让浏览器每次滚动就检查元素是否出现在窗口可视范围内： 12345$(window).on(\"scroll\", function&#123; if (isVisible($node))&#123; console.log(true); &#125;&#125;) 我们已经很接近了，现在我们要做的是，让元素只在第一次被检查到时打印true，之后就不再打印了 1234567891011var hasShowed = false;$(window).on(\"sroll\",function&#123; if (hasShowed) &#123; return; &#125; else &#123; if (isVisible($node)) &#123; hasShowed = !hasShowed; console.log(true); &#125; &#125;&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"懒加载","slug":"懒加载","permalink":"/tags/懒加载/"},{"name":"lazyload","slug":"lazyload","permalink":"/tags/lazyload/"}]},{"title":"解决https请求下发送http请求问题","slug":"解决https请求下发送http请求问题 ","date":"2016-08-24T16:00:00.000Z","updated":"2017-08-25T12:26:26.803Z","comments":true,"path":"2016/08/25/解决https请求下发送http请求问题 /","link":"","permalink":"/2016/08/25/解决https请求下发送http请求问题 /","excerpt":"","text":"在https页面下的带有相对路径的请求都会与页面的协议保持一致。如果想在https页面下发送http的请求，如果只把链接写死成为http的\b绝对路径是不够的，这样会导致http的请求与总页面https的请求的session不一致。 为什么呢？原因是https的请求中服务器发回的cookie是标记为”secure”的，而http的请求时非”secure”,”由于在服务器端secure”的cookie不会兼容非”secure”的，所以当http的请求携带着同一jsessionid的cookie到达服务器时，服务器拒绝非”secure”，进而返回的结果是一个新的非”secure”的cookie，于是两个session就不同了。 怎么解决呢？由原因分析可知，两个session不同，更具体说是cookie的状态不同。那么办法是，在接收到第一个https请求的响应后 到 发送下面的http请求之前，将cookie去”secure”状态，但是又要保证jsessionid不变。具体操作可以新建一个cookie(新建的是非”secure”状态)，然后赋予同一个jessionid，然后加入response中。 代码如下： 1234Cookie cookie = new Cookie(\"JSESSIONID\", req.getSession().getId());cookie.setPath(req.getContextPath());resp.addCookie(cookie); 本文转载自http://blog.csdn.NET/songgeabc/article/details/18192057","categories":[{"name":"Http","slug":"Http","permalink":"/categories/Http/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"/tags/跨域/"}]},{"title":"JavaScript深入之闭包(转)","slug":"闭包","date":"2016-08-19T16:00:00.000Z","updated":"2017-08-25T12:43:39.284Z","comments":true,"path":"2016/08/20/闭包/","link":"","permalink":"/2016/08/20/闭包/","excerpt":"","text":"JavaScript深入之闭包 介绍理论上的闭包和实践上的闭包，以及从作用域链的角度解析经典的闭包题。 定义MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量 举个例子1234567var a = 1;function foo() &#123; console.log(a);&#125;foo(); foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛…… 还真是这样的！ 所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。 咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？ 别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义： ECMAScript中，闭包指的是： 1.从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 2.从实践角度：以下函数才算是闭包： (1).即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） (2).在代码中引用了自由变量 分析1234567891011var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;var foo = checkscope();foo(); 首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。 另一个与这段代码相似的例子，在《JavaScript深入之执行上下文》中有着非常详细的分析。如果看不懂以下的执行过程，建议先阅读这篇文章。 这里直接给出简要的执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？ 以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……) 然而 JavaScript 却是可以的！ 必刷题1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为：123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的作用域链为：123data[0]Context = &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。 data[1] 和 data[2] 是一样的道理。 所以让我们改成闭包看看：12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function (i) &#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125;data[0]();data[1]();data[2](); 当执行到 data[0] 函数之前，此时全局上下文的 VO 为：123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 跟没改之前一模一样。 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125; 匿名函数执行上下文的 AO 为：123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是 0。 data[1] 和 data[2] 是一样的道理。 转自 https://juejin.im/post/590159d8a22b9d0065c2d918","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"git远程操作","slug":"git远程操作","date":"2016-08-14T16:00:00.000Z","updated":"2017-08-25T12:25:22.668Z","comments":true,"path":"2016/08/15/git远程操作/","link":"","permalink":"/2016/08/15/git远程操作/","excerpt":"","text":"git远程操作 在开源中国的码云平台做代码的远程提交 12345678910111213码云地址:https://git.oschina.net登录注册:此步骤省略具体操作步骤true1. 在平台上通过新建项目创建一个代码仓库true2. 把远程仓库的代码clone到本地truetrue在本地电脑上创建一个文件夹(通过cd命令进入此文件夹)，执行以下命令truetruegit clone https://.... # 通过clone命令把代码clone到本地true3. 使用编辑器打开文件夹,对内容做修改true4. 修改之后对代码做本地的缓存和提交truetruegit add . #把文件加入缓存区truetruegit commit -m '提交信息' #把代码提交到本地仓库true5. 把本地代码push(推送)到远程服务器truetruegit push git客户端gui工具 tortoisegit sourcetree github上创建个人主页 在github上创建一个项目名为 xxx.github.io的仓库此仓库中放置的静态html文件可以直接通过外网地址进行访问 创建个人github主页的步骤为 1231. 打开github,登陆个人账号2. 创建项目,项目名为 用户名.github.io3. 在此项目中提交一些可以直接访问的静态html文件 查看、添加、提交、删除、找回，重置修改文件git help # 显示command的help git show # 显示某次提交的内容 git show $id git co – # 抛弃工作区修改 git co . # 抛弃工作区修改 git add # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm # 从版本库中删除文件 git rm –cached # 从版本库中删除文件，但不删除文件 git reset # 从暂存区恢复到工作文件 git reset – . # 从暂存区恢复到工作文件 git reset –hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am “some comments” git ci –amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件diffgit diff # 比较当前文件和暂存区文件差异 git diff git diff &lt; id2&gt; # 比较两次提交之间的差异 git diff .. # 在两个分支之间比较 git diff –staged # 比较暂存区和版本库差异 git diff –cached # 比较暂存区和版本库差异 git diff –stat # 仅仅比较统计信息 查看提交记录git log git log # 查看该文件每次提交记录 git log -p # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log –stat #查看提交统计信息 tig Mac上可以使用tig代替diff和log，brew install tig Git 本地分支管理 查看、切换、创建和删除分支git br -r # 查看远程分支 git br # 创建新的分支 git br -v # 查看各个分支最后提交信息 git br –merged # 查看已经被合并到当前分支的分支 git br –no-merged # 查看尚未被合并到当前分支的分支 git co # 切换到某个分支 git co -b # 创建新的分支，并且切换过去 git co -b # 基于branch创建新的new_branch git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git co $id -b # 把某次历史提交记录checkout出来，创建成一个分支 git br -d # 删除某个分支 git br -D # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebasegit merge # 将branch分支合并到当前分支 git merge origin/master –no-ff # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master # 将master rebase到branch，相当于： git co &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge Git补丁管理(方便在多台机器上开发同步时用) git diff &gt; ../sync.patch # 生成补丁 git apply ../sync.patch # 打补丁 git apply –check ../sync.patch #测试补丁能否成功 Git暂存管理git stash # 暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地 git pull –no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 git fetch origin # 抓取远程仓库更新 git merge origin/master # 将远程主分支合并到本地当前分支 git co –track origin/branch # 跟踪某个远程分支创建相应的本地分支 git co -b origin/ # 基于远程分支创建本地分支，功能同上 git push # push所有分支 git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin # 创建远程分支， origin是远程仓库名 git push origin : # 创建远程分支 git push origin : #先删除本地分支(git br -d )，然后再push删除远程分支 Git远程仓库管理GitHubgit remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址 git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm # 删除远程仓库 创建远程仓库git clone –bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git –bare init # 在服务器创建纯仓库 git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库git branch –set-upstream master origin/master git branch –set-upstream develop origin/develop","categories":[{"name":"版本管理","slug":"版本管理","permalink":"/categories/版本管理/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}]}]}