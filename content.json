{"meta":{"title":"博客","subtitle":null,"description":null,"author":"陈志远","url":""},"pages":[{"title":"About","date":"2017-08-25T10:54:14.936Z","updated":"2017-08-16T08:34:47.338Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-08-25T10:54:14.942Z","updated":"2017-08-16T08:34:47.338Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-08-25T10:54:14.961Z","updated":"2017-08-16T08:34:47.339Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-08-25T10:54:14.965Z","updated":"2017-08-25T06:42:55.621Z","comments":true,"path":"tags/tags1/index.html","permalink":"/tags/tags1/index.html","excerpt":"","text":"Tag: tags1 | Hexo Hexo Home Archives + Categories + Tags About (function (window) { var INSIGHT_CONFIG = { TRANSLATION: { POSTS: 'Posts', PAGES: 'Pages', CATEGORIES: 'Categories', TAGS: 'Tags', UNTITLED: '(Untitled)', }, ROOT_URL: '/', CONTENT_URL: '/content.json', }; window.INSIGHT_CONFIG = INSIGHT_CONFIG; })(window); Home Archives + Categories + Tags About PPOffice Web Developer &amp; Designer Harbin, China FOLLOW 5 posts 1 tag #tags1 js变量提升和函数提升 2016-08-25 type1 tags1 recent js变量的只声明不赋值 2017-08-25 js上下文 2017-08-25 js作用域和作用域链 2017-08-25 2017-08-25 type1 js变量提升和函数提升 2016-08-25 categories type11 archives August 20174August 20161 tags tags11 tag cloud tags1 links Hexo &copy; 2017 John Doe Powered by Hexo. Theme by PPOffice var disqus_config = function () { this.page.identifier = ''; }; (function() { var d = document, s = d.createElement('script'); s.src = '//' + 'hexo-theme-icarus' + '.disqus.com/count.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })();"},{"title":"","date":"2017-08-25T10:54:14.956Z","updated":"2017-08-25T06:42:55.618Z","comments":true,"path":"categories/type1/index.html","permalink":"/categories/type1/index.html","excerpt":"","text":"Category: type1 | Hexo Hexo Home Archives + Categories + Tags About (function (window) { var INSIGHT_CONFIG = { TRANSLATION: { POSTS: 'Posts', PAGES: 'Pages', CATEGORIES: 'Categories', TAGS: 'Tags', UNTITLED: '(Untitled)', }, ROOT_URL: '/', CONTENT_URL: '/content.json', }; window.INSIGHT_CONFIG = INSIGHT_CONFIG; })(window); Home Archives + Categories + Tags About PPOffice Web Developer &amp; Designer Harbin, China FOLLOW 5 posts 1 tag type1 js变量提升和函数提升 2016-08-25 type1 tags1 recent js变量的只声明不赋值 2017-08-25 js上下文 2017-08-25 js作用域和作用域链 2017-08-25 2017-08-25 type1 js变量提升和函数提升 2016-08-25 categories type11 archives August 20174August 20161 tags tags11 tag cloud tags1 links Hexo &copy; 2017 John Doe Powered by Hexo. Theme by PPOffice var disqus_config = function () { this.page.identifier = ''; }; (function() { var d = document, s = d.createElement('script'); s.src = '//' + 'hexo-theme-icarus' + '.disqus.com/count.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })();"}],"posts":[{"title":"js变量提升和函数提升","slug":"js变量和函数的提升","date":"2017-01-31T16:00:00.000Z","updated":"2017-08-25T13:04:40.084Z","comments":true,"path":"2017/02/01/js变量和函数的提升/","link":"","permalink":"/2017/02/01/js变量和函数的提升/","excerpt":"","text":"一、先抛出一个笔试题目123456789101112var a = 100;function fn() &#123; alert(a);//undefined var a = 200; alert(a);//200&#125;fn();alert(a);//100var a;alert(a);//100var a = 300;alert(a);//300 知识点1 变量的提升 上面的代码实际的执行顺序如下12345678910111213var a;//全局作用域范围内，此时只是声明，并没有赋值a = 100;function fn()&#123; var a; alert(a);//undefined a = 200; alert(a);//200&#125;fn();alert(a);//100alert(a);//100a = 300;alert(a);//300 知识点2 函数的提升 js中创建函数有两种方式：函数声明式和函数字面量式。只有函数声明才存在函数提升！如: 1234console.log(f1); // function f1() &#123;&#125; console.log(f2); // undefined function f1() &#123;&#125;var f2 = function() &#123;&#125; 只所以会有以上的打印结果，是由于js中的函数提升导致代码实际上是按照以下来执行的：1234function f1() &#123;&#125; // 函数提升，整个代码块提升到文件的最开始console.log(f1); console.log(f2); var f2 = function() &#123;&#125; 结语：基本上就是这样，要熟练掌握的话可以多做些练习，test:1234console.log(f1); console.log(f2); function f1() &#123;console.log('aa')&#125;var f2 = function() &#123;&#125; 123456(function() &#123; console.log(a);//undefined a = 'aaa'; var a = 'bbb'; console.log(a);//bbb&#125;)();","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"js变量的只声明不赋值","slug":"js变量的只声明不赋值","date":"2017-01-29T16:00:00.000Z","updated":"2017-08-25T13:03:19.885Z","comments":true,"path":"2017/01/30/js变量的只声明不赋值/","link":"","permalink":"/2017/01/30/js变量的只声明不赋值/","excerpt":"","text":"先抛出一个两个例子12345678 function box(obj)&#123; var obj;// obj = &#123;name:122&#125; console.log(obj);&#125;var obj = new Object(&#123;name:1&#125;);box(obj);console.log(obj.name); 传参相当于在实际执行的时候执行了 this.obj = obj 12345678910function box() &#123; var obj; // obj = &#123;name:122&#125; console.log(obj);//undefined&#125;var obj = new Object(&#123; name: 1&#125;);box(obj);console.log(obj.name); 所以第二个自己是undefined","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"js作用域和作用域链","slug":"js作用域和作用域链","date":"2017-01-12T16:00:00.000Z","updated":"2017-08-25T13:05:59.947Z","comments":true,"path":"2017/01/13/js作用域和作用域链/","link":"","permalink":"/2017/01/13/js作用域和作用域链/","excerpt":"","text":"一、先抛出一个笔试题目123456789101112var a = 100; function fn() &#123; alert(a);//undefined var a = 200; alert(a);//200 &#125; fn(); alert(a);//100 var a; alert(a);//100 var a = 300; alert(a);//300 知识点1 变量的提升 上面的代码实际的执行顺序如下12345678910111213var a;//全局作用域范围内，此时只是声明，并没有赋值a = 100;function fn()&#123; var a; alert(a);//undefined a = 200; alert(a);//200&#125;fn();alert(a);//100alert(a);//100a = 300;alert(a);//300 知识点2 函数的提升 js中创建函数有两种方式：函数声明式和函数字面量式。只有函数声明才存在函数提升！如:1234console.log(f1); // function f1() &#123;&#125; console.log(f2); // undefined function f1() &#123;&#125;var f2 = function() &#123;&#125; 只所以会有以上的打印结果，是由于js中的函数提升导致代码实际上是按照以下来执行的：1234function f1() &#123;&#125; // 函数提升，整个代码块提升到文件的最开始console.log(f1); console.log(f2); var f2 = function() &#123;&#125; 结语：基本上就是这样，要熟练掌握的话可以多做些练习，test:1234console.log(f1); console.log(f2); function f1() &#123;console.log('aa')&#125;var f2 = function() &#123;&#125; 123456(function() &#123; console.log(a);//undefined a = 'aaa'; var a = 'bbb'; console.log(a);//bbb&#125;)();","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"js你说不知道的编译","slug":"js你所不知道的预编译","date":"2016-12-28T16:00:00.000Z","updated":"2017-08-25T13:07:41.708Z","comments":true,"path":"2016/12/29/js你所不知道的预编译/","link":"","permalink":"/2016/12/29/js你所不知道的预编译/","excerpt":"","text":"JavaScript三部曲前言 在JavaScript中变量和函数的声明会提升到最顶部执行。 函数的提升高于变量的提升。 函数内部如果用var声明了相同名称的外部变量，函数将不再向上寻找。 匿名函数不会提升。 不同script脚本块中的函数互不影响。脚本执行引擎都做了什么 语法分析 预编译 解释执行 通俗讲就是 在执行代码前，还有两个步骤 语法分析很简单，就是引擎检查你的代码有没有什么低级的语法错误 解释执行顾名思义便是执行代码了 预编译简单理解就是在内存中开辟一些空间，存放一些变量与函数理解了预编译对大家理解作用域同样有帮助 JS预编译什么时候发生 我当初思维误区也发生在这里 预编译到底什么时候发生 希望大家不要让上面的运行过程让你产生误会， 误以为预编译仅仅发生在script内代码块执行前 这倒并没有错 预编译确确实实在script代码内执行前发生了 但是它大部分会发生在函数执行前JS预编译实例几个概念 变量声明 关键词var 函数声明 关键词function注意函数声明和函数表达是的区别1234567891011121314 &lt;script&gt; var a = 1;// 变量声明 function b(y)&#123;//函数声明 var x = 1; console.log('so easy'); &#125;; var c = function()&#123;//是变量声明而不是函数声明！！ //... &#125; b(100);&lt;/script&gt;&lt;script&gt; var d = 0;&lt;/script&gt; 让我们看看引擎对这段代码做了什么吧 页面产生便创建了GO全局对象（Global Object）（也就是大家熟悉的window对象） 第一个脚本文件加载 脚本加载完毕后，分析语法是否合法 开始预编译 查找变量声明，作为GO属性，值赋予undefined 查找函数声明，作为GO属性，值赋予函数体12345678910 //伪代码GO/window = &#123; //页面加载创建GO同时，创建了document、navigator、screen等等属性，此处省略 a: undefined, c: undefined， b: function(y)&#123; var x = 1; console.log('so easy'); &#125;&#125; 解释执行代码（直到执行函数b）123456789101112//伪代码GO/window = &#123; //变量随着执行流得到初始化 a: 1, c: function()&#123; //... &#125;, b: function(y)&#123; var x = 1; console.log('so easy'); &#125;&#125; 执行函数b之前，发生预编译 创建AO活动对象（Active Object） 查找形参和变量声明，值赋予undefined 实参值赋给形参 查找函数声明，值赋予函数体123456//伪代码AO = &#123; //创建AO同时，创建了arguments等等属性，此处省略 y: 100, x: undefined&#125; 解释执行函数中代码 第一个脚本文件执行完毕，加载第二个脚本文件注意每个script是独立的,不会预编译下一个scipt 第二个脚本文件加载完毕后，进行语法分析 语法分析完毕，开始预编译 重复最开始的预编译步骤…… 结语预编译阶段发生变量声明和函数声明，没有初始化行为（赋值），匿名函数不参与预编译只有在解释执行阶段才会进行变量初始化 预编译(函数执行前)※ 创建AO对象（Active Object） 查找函数形参及函数内变量声明，形参名及变量名作为AO对象的属性，值为undefined 实参形参相统一，实参值赋给形参 查找函数声明，函数名作为AO对象的属性，值为函数引用 预编译(脚本代码块script执行前) 查找全局变量声明（包括隐式全局变量声明，省略var声明），变量名作全局对象的属性，值为undefined 查找函数声明，函数名作为全局对象的属性，值为函数引用 理解了预编译对理解提升行为，this指向，作用域及性能等问题都有很大帮助","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"Node.js的学习--使用cheerio抓取网页数据","slug":"Node.js的学习--使用cheerio抓取网页数据","date":"2016-12-17T16:00:00.000Z","updated":"2017-08-25T13:06:06.592Z","comments":true,"path":"2016/12/18/Node.js的学习--使用cheerio抓取网页数据/","link":"","permalink":"/2016/12/18/Node.js的学习--使用cheerio抓取网页数据/","excerpt":"","text":"打算要写一个公开课网站，缺少数据，就决定去网易公开课去抓取一些数据。 前一阵子看过一段时间的Node.js，而且Node.js也比较适合做这个事情，就打算用Node.js去抓取数据。 关键是抓取到网页之后如何获取到想要的数据呢？然后就发现了cheerio，用来解析html非常方便，就像在浏览器中使用jquery一样。 使用如下命令安装cheerio npm install cheerio Cheerio安装完成， 我们就可以开始工作了。 首先让我们来看一段javascript代码 这段代码可以下载任意一个网页的内容。将其放入到curl.js中，并导出。12345678910111213141516171819 var http = require(\"http\"); // Utility function that downloads a URL and invokes// callback with the data.function download(url, callback) &#123; http.get(url, function(res) &#123; var data = \"\"; res.on('data', function (chunk) &#123; data += chunk; &#125;); res.on(\"end\", function() &#123; callback(data); &#125;); &#125;).on(\"error\", function() &#123; callback(null); &#125;);&#125;exports.download = download; 然后是使用cheerio解析html，找到想要的数据。 我们先来自己分析一下页面。我们要抓取http://v.163.com/special/opencourse/englishs1.html这个页面中的视频，视频的地址都在下载的按钮里。其中一个下载按钮的html的代码如下：12&lt;a class=\"downbtn\" href=\"http://mov.bn.netease.com/mobilev/2013/1/F/G/S8KTEF7FG.mp4\" id=\"M8KTEKR84\" target=\"_blank\"&gt;&lt;/a&gt; 我们取到其中的href属性，只需要进行如下选择即可12$(\"a.downbtn\").attr(\"href\"); 在是现实，我们可以在index.js中写入如下代码12345678910111213141516171819var cheerio = require(\"cheerio\");var server = require(\"./curl\"); var url = \"http://v.163.com/special/opencourse/englishs1.html\"server.download(url, function(data) &#123; if (data) &#123; //console.log(data); var $ = cheerio.load(data); $(\"a.downbtn\").each(function(i, e) &#123; console.log($(e).attr(\"href\")); &#125;); console.log(\"done\"); &#125; else &#123; console.log(\"error\"); &#125; &#125;);","categories":[{"name":"Node","slug":"Node","permalink":"/categories/Node/"},{"name":"爬虫","slug":"Node/爬虫","permalink":"/categories/Node/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"/tags/爬虫/"},{"name":"cheerio","slug":"cheerio","permalink":"/tags/cheerio/"}]},{"title":"深入理解JavaScript执行上下文、函数堆栈、提升的概念","slug":"js深入理解JavaScript执行上下文、函数堆栈、提升的概念 ","date":"2016-12-01T16:00:00.000Z","updated":"2017-08-25T12:52:13.800Z","comments":true,"path":"2016/12/02/js深入理解JavaScript执行上下文、函数堆栈、提升的概念 /","link":"","permalink":"/2016/12/02/js深入理解JavaScript执行上下文、函数堆栈、提升的概念 /","excerpt":"","text":"首先明确几个概念EC：函数执行环境（或执行上下文），Execution ContextECS：执行环境栈，Execution Context StackVO：变量对象，Variable ObjectAO：活动对象，Active Objectscope chain：作用域链 EC执行上下文每次当控制器转到ECMAScript可执行代码的时候，就会进入到一个执行上下文。那什么是可执行代码呢？ 可执行代码的类型 全局代码（Global code）这种类型的代码是在”程序”级处理的：例如加载外部的js文件或者本地”“标签内的代码。全局代码不包括任何function体内的代码。 这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。 函数代码（Function code）任何一个函数体内的代码，但是需要注意的是，具体的函数体内的代码是不包括内部函数的代码。 Eval代码（Eval code）eval内部的代码ECS（执行环境栈）我们用MDN上的一个例子来引入函数执行栈的概念12345678910111213141516function foo(i) &#123; if (i &lt; 0) return; console.log('begin:' + i); foo(i - 1); console.log('end:' + i);&#125;foo(2);// 输出:// begin:2// begin:1// begin:0// end:0// end:1// end:2 ······························转····························· 先了解一下函数执行上下文堆栈的概念浏览器中的JS解释器被实现为单线程，这也就意味着同一时间只能发生一件事情，其他的行为或事件将会被放在叫做执行栈里面排队。下面的图是单线程栈的抽象视图： 当浏览器首次载入你的脚本，它将默认进入全局执行上下文。如果，你在你的全局代码中调用一个函数，你程序的时序将进入被调用的函数，并创建一个新的执行上下文，并将新创建的上下文压入执行栈的顶部。如果你调用当前函数内部的其他函数，相同的事情会在此上演。代码的执行流程进入内部函数，创建一个新的执行上下文并把它压入执行栈的顶部。浏览器总会执行位于栈顶的执行上下文，一旦当前上下文函数执行结束，它将被从栈顶弹出，并将上下文控制权交给当前的栈。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。 VO（变量对象）/AO（活动对象）这里为什么要用一个/呢？按照字面理解，AO其实就是被激活的VO，两个其实是一个东西。 变量对象（Variable object）是说JS的执行上下文中都有个对象用来存放执行上下文中可被访问但是不能被delete的函数标示符、形参、变量声明等。它们会被挂在这个对象上，对象的属性对应它们的名字对象属性的值对应它们的值但这个对象是规范上或者说是引擎实现上的不可在JS环境中访问到活动对象 激活对象（Activation object）有了变量对象存每个上下文中的东西，但是它什么时候能被访问到呢？就是每进入一个执行上下文时，这个执行上下文儿中的变量对象就被激活，也就是该上下文中的函数标示符、形参、变量声明等就可以被访问到了 EC建立的细节 创建阶段【当函数被调用，但未执行任何其内部代码之前】 创建作用域链（Scope Chain） 创建变量，函数和参数。 求”this“的值 执行阶段初始化变量的值和函数的引用，解释/执行代码。我们可以将每个执行上下文抽象为一个对象，这个对象具有三个属性ECObj: { scopeChain: { / 变量对象（variableObject）+ 所有父级执行上下文的变量对象/ }, variableObject: { /函数 arguments/参数，内部变量和函数声明 / }, this: {}} 解释器执行代码的伪逻辑 查找调用函数的代码。 执行代码之前，先进入创建上下文阶段： 初始化作用域链 创建变量对象： 创建arguments对象，检查上下文，初始化参数名称和值并创建引用的复制。 扫描上下文的函数声明（而非函数表达式）： 为发现的每一个函数，在变量对象上创建一个属性——确切的说是函数的名字——其有一个指向函数在内存中的引用。 如果函数的名字已经存在，引用指针将被重写。 扫描上下文的变量声明： 为发现的每个变量声明，在变量对象上创建一个属性——就是变量的名字，并且将变量的值初始化为undefined 如果变量的名字已经在变量对象里存在，将不会进行任何操作并继续扫描。 求出上下文内部this的值。 激活/代码执行阶段： 在当前上下文上运行/解释函数代码，并随着代码一行行执行指派变量的值。 VO — 对应上述第二个阶段123456function foo(i)&#123; var a = 'hello' var b = function()&#123;&#125; function c()&#123;&#125;&#125;foo(22) 当我们调用foo(22)时，整个创建阶段是下面这样的1234567891011121314ECObj = &#123; scopChain： &#123;...&#125;, variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: undefined, b: undefined &#125;, this: &#123; ... &#125;&#125; 正如我们看到的，在上下文创建阶段，VO的初始化过程如下（该过程是有先后顺序的：函数的形参==&gt;&gt;函数声明==&gt;&gt;变量声明）： 函数的形参（当进入函数执行上下文时） —— 变量对象的一个属性，其属性名就是形参的名字，其值就是实参的值；对于没有传递的参数，其值为undefined 函数声明（FunctionDeclaration, FD） —— 变量对象的一个属性，其属性名和值都是函数对象创建出来的；如果变量对象已经包含了相同名字的属性，则替换它的值 变量声明（var，VariableDeclaration） —— 变量对象的一个属性，其属性名即为变量名，其值为undefined;如果变量名和已经声明的函数名或者函数的参数名相同，**则不会影响已经存在的属性。** 如何理解函数声明过程中如果变量对象已经包含了相同名字的属性，则替换它的值这句话？ 看如下这段代码：12345function foo1(a)&#123; console.log(a) function a()&#123;&#125; &#125;foo1(20)//'function a()&#123;&#125;' 根据上面的介绍，我们知道VO创建过程中，函数形参的优先级是高于函数的声明的，结果是函数体内部声明的function a(){}覆盖了函数形参a的声明，因此最后输出a是一个function 如何理解变量声明过程中如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性这句话？123456//情景一：与参数名相同function foo2(a)&#123; console.log(a) var a = 10&#125;foo2(20) //'20' 12345678//情景二：与函数名相同function foo2()&#123; console.log(a) var a = 10 function a()&#123;&#125;&#125;foo2() //'function a()&#123;&#125;' 下面是几个比较有趣的例子，当做加餐小菜，大家细细品味。这里给出一句话当做参考： 函数声明比变量优先级要高，并且定义过程不会被变量覆盖，除非是赋值 123456function foo3(a)&#123; var a = 10 function a()&#123;&#125; console.log(a)&#125;foo3(20) //'10' 123456function foo3(a)&#123; var a function a()&#123;&#125; console.log(a)&#125;foo3(20) //'function a()&#123;&#125;' 123456function foo2(a) &#123; console.log(a) var a = 10 function a() &#123;&#125;&#125;foo2(20) //'function a()&#123;&#125;' 123456function foo2(a) &#123; var a = 10 function a() &#123;&#125; console.log(a) &#125; foo2(20) //'10' 小结：&gt;函数声明的提升&gt;赋值的优先级&gt;变量的提升 函数声明（FunctionDeclaration, FD） —— 变量对象的一个属性，其属性名和值都是函数对象创建出来的；如果变量对象已经包含了相同名字的属性，则替换它的值。可以理解为声明则赋值一个指针？ 12345678function foo2(a) &#123; var a = 10 function a() &#123; // &#125; console.log(a) &#125; foo2(20) //'function a()' 变量声明（var，VariableDeclaration） —— 变量对象的一个属性，其属性名即为变量名，其值为undefined;如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性。 AO — 对应第三个阶段正如我们看到的，创建的过程仅负责处理定义属性的名字，而并不为他们指派具体的值，当然还有对形参/实参的处理。一旦创建阶段完成，执行流进入函数并且激活/代码执行阶段，看下函数执行完成后的样子：1234567891011121314 ECObj = &#123; scopeChain: &#123; ... &#125;, variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: 'hello', b: pointer to function privateB() &#125;, this: &#123; ... &#125;&#125; 提升（Hoisting）对于下面的代码，相信很多人都能一眼看出输出结果，但是却很少有人能给出为什么会产生这种输出结果的解释。12345678910111213(function() &#123; console.log(typeof foo); // 函数指针 console.log(typeof bar); // undefined var foo = 'hello', bar = function() &#123; return 'world'; &#125;; function foo() &#123; return 'hello'; &#125;&#125;()); 为什么我们能在foo声明之前访问它？回想在VO的创建阶段，我们知道函数在该阶段就已经被创建在变量对象中。所以在函数开始执行之前，foo已经被定义了。 Foo被声明了两次，为什么foo显示为函数而不是undefined或字符串？我们知道，在创建阶段，函数声明是优先于变量被创建的。而且在变量的创建过程中，如果发现VO中已经存在相同名称的属性，则不会影响已经存在的属性。因此，对foo()函数的引用首先被创建在活动对象里，并且当我们解释到var foo时，我们看见foo属性名已经存在，所以代码什么都不做并继续执行。 为什么bar的值是undefined？bar采用的是函数表达式的方式来定义的，所以bar实际上是一个变量，但变量的值是函数，并且我们知道变量在创建阶段被创建但他们被初始化为undefined，这也是为什么函数表达式不会被提升的原因。 总结： EC分为两个阶段，创建执行上下文和执行代码。 每个EC可以抽象为一个对象，这个对象具有三个属性，分别为：作用域链Scope，VO|AO（AO，VO只能有一个）以及this。 函数EC中的AO在进入函数EC时，确定了Arguments对象的属性；在执行函数EC时，其它变量属性具体化。 EC创建的过程是由先后顺序的：参数声明 &gt; 函数声明 &gt; 变量声明 12345678910function foo2(a) &#123; console.log(a)//function a() var a = 10 function a() &#123; console.log(fsdf); &#125; console.log(a)//10 console.log(a())//报错 a is not a function &#125; foo2(20) 解释：提升的过程函数声明的优先级比形参和变量高，后面的执行代码的阶段赋值行为是在最后面,因此打印10，最后的console会报错","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"mongodb mongoose node中间件增删改查方法","slug":"mongose中间件","date":"2016-11-27T16:00:00.000Z","updated":"2017-08-25T13:29:10.350Z","comments":true,"path":"2016/11/28/mongose中间件/","link":"","permalink":"/2016/11/28/mongose中间件/","excerpt":"","text":"官网 http://mongoosejs.com/docs/api.html#model_Model.update 命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344#model.js$whereincrementmodelModelremovesaveaggregatebulkWritecountcreatedeleteManydeleteOnediscriminatordistinctensureIndexesfindfindByIdfindByIdAndRemovefindByIdAndUpdatefindOnefindOneAndRemovefindOneAndUpdategeoNeargeoSearchhydrateinsertManymapReducepopulateremovereplaceOnetranslateAliasesupdateupdateManyupdateOnewhere$wherebasebaseModelNamecollectiondbdiscriminatorsmodelNameschema","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"/tags/mongodb/"}]},{"title":"Vue 生命周期","slug":"vue.生命周期","date":"2016-11-14T16:00:00.000Z","updated":"2017-08-25T13:30:22.000Z","comments":true,"path":"2016/11/15/vue.生命周期/","link":"","permalink":"/2016/11/15/vue.生命周期/","excerpt":"","text":"前言 在使用vue一个多礼拜后，感觉现在还停留在初级阶段，虽然知道怎么和后端做数据交互，但是对于mounted这个挂载还不是很清楚的。放大之，对vue的生命周期不甚了解。只知道简单的使用，而不知道为什么，这对后面的踩坑是相当不利的。 因为我们有时候会在几个钩子函数里做一些事情，什么时候做，在哪个函数里做，我们不清楚。 vue生命周期简介 生命周期探究&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/vue/2.1.3/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var app = new Vue(&#123; el: '#app', data: &#123; message : \"xuxiao is boy\" &#125;, beforeCreate: function () &#123; console.group('beforeCreate 创建前状态===============》'); console.log(\"%c%s\", \"color:red\" , \"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //undefined console.log(\"%c%s\", \"color:red\",\"message: \" + this.message) &#125;, created: function () &#123; console.group('created 创建完毕状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 &#125;, beforeMount: function () &#123; console.group('beforeMount 挂载前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + (this.$el)); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 &#125;, mounted: function () &#123; console.group('mounted 挂载结束状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 &#125;, beforeUpdate: function () &#123; console.group('beforeUpdate 更新前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); &#125;, updated: function () &#123; console.group('updated 更新完成状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); &#125;, beforeDestroy: function () &#123; console.group('beforeDestroy 销毁前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); create 和 mounted 相关 beforecreated：el 和 data 并未初始化created:完成了 data 数据的初始化，el没有beforeMount：完成了 el 和 data 初始化mounted ：完成挂载 生命周期总结 beforecreate : 举个栗子：可以在这加个loading事件created ：在这结束loading，还做一些初始化，实现函数自执行mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情beforeDestory： 你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容 参考文献 https://segmentfault.com/q/10… http://www.cnblogs.com/gagag/…","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"}]},{"title":"Vue loading加载动画组件","slug":"vue loading组件","date":"2016-11-01T16:00:00.000Z","updated":"2017-08-25T13:29:09.036Z","comments":true,"path":"2016/11/02/vue loading组件/","link":"","permalink":"/2016/11/02/vue loading组件/","excerpt":"","text":"实现效果实现了加载是颜色的变化以及进度条的变化 下面是代码实现 html页面测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style&gt; .spinner &#123; transform-origin: center; animation: rotator 6s linear infinite; background-color:#cccccc; width:150px; height:150px; &#125; @keyframes rotator &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(270deg); &#125; &#125; .path &#123; stroke-dasharray: 187; stroke-dashoffset: 0; transform-origin: center; animation: dash 2s ease-in-out infinite, colors 4s ease-in-out infinite; &#125; @keyframes colors &#123; 0% &#123; stroke: #4285F4; &#125; 25% &#123; stroke: #DE3E35; &#125; 50% &#123; stroke: #F7C223; &#125; 75% &#123; stroke: #1B9A59; &#125; 100% &#123; stroke: #4285F4; &#125; &#125; @keyframes dash &#123; 0% &#123; stroke-dashoffset: 187; &#125; 50% &#123; stroke-dashoffset: 93.5; &#125; 100% &#123; stroke-dashoffset: 0; &#125; &#125;&lt;/style&gt;&lt;body&gt; &lt;svg class=\"spinner\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;circle class=\"path\" stroke=\"red\" fill=\"none\" stroke-width=\"6\" cx=\"75\" cy=\"75\" r=\"30\"&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/body&gt;&lt;/html&gt; vue Loading组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;template&gt; &lt;div class=\"loading-component\"&gt; &lt;svg class=\"spinner\" :style=\"loadingSize\" viewBox=\"0 0 66 66\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;circle class=\"path\" :style=\"loadingColor\" fill=\"none\" :stroke-width=\"stroke\" cx=\"33\" cy=\"33\" r=\"30\"&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=\"text/ecmascript-6\"&gt; export default &#123; props: &#123; size: &#123; type: Number, default: 50 &#125;, stroke: &#123; type: Number, default: 3.5 &#125;, color: &#123; type: String, default: '#ed424b' &#125; &#125;, computed: &#123; loadingSize() &#123; const newSize = this.size + 'px' return &#123; width: newSize, height: newSize &#125; &#125;, loadingColor() &#123; return &#123; stroke: this.color &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=\"less\" type=\"text/less\"&gt; .loading-component &#123; display: inline-block; pointer-events: none; will-change: transform, opacity; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); &#125; //2 * pi * r = 188.4 @offset: 187; @duration: 1.4s; //设置外层旋转形成加载的效果 .spinner &#123; transform-origin: center; animation: rotator @duration linear infinite; &#125; @keyframes rotator &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(270deg); &#125; &#125; .path &#123; stroke-dasharray: @offset; stroke-dashoffset: 0; transform-origin: center; // 设置颜色变化以及dash长度的变化 animation: dash @duration ease-in-out infinite, colors @duration ease-in-out infinite; &#125; @keyframes colors &#123; 0% &#123; stroke: #4285F4; &#125; 25% &#123; stroke: #DE3E35; &#125; 50% &#123; stroke: #F7C223; &#125; 75% &#123; stroke: #1B9A59; &#125; 100% &#123; stroke: #4285F4; &#125; &#125; //让空白部分慢慢减少 @keyframes dash &#123; 0% &#123; stroke-dashoffset: @offset; &#125; 50% &#123; stroke-dashoffset: @offset/4; &#125; 100% &#123; stroke-dashoffset: @offset; &#125; &#125;&lt;/style&gt;","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"}]},{"title":"v-model本质（以底部导航切换为例子）","slug":"v-model","date":"2016-10-24T16:00:00.000Z","updated":"2017-08-25T13:29:10.021Z","comments":true,"path":"2016/10/25/v-model/","link":"","permalink":"/2016/10/25/v-model/","excerpt":"","text":"v-modelv-model本质是1&lt;input type=\"text\" v-bind:value=\"dataA\" v-on:input=\"dataA = $event.target.value\" /&gt; 1.Index页面该页面包含了m-tabbar和m-tabbar-item组件，目的是实现底部tab切换m-tabbar传入 v-mode:”select”实际上是v-bind:value=”select” v-on:input=”select = $event.target.value”v-bind:value=”select”传入的props(父-&gt;子)v-on:input=”select = $event.target.value” 监听$emit(‘input’,…)v-model 数据双向绑定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div&gt; &lt;m-tabbar v-model=\"select\"&gt; &lt;m-tabbar-item id='tab1'&gt; &lt;img src=\"../assets/images/ic_tab_home_normal.png\" alt=\"\" slot=\"icon-normal\"&gt; &lt;img src=\"../assets/images/ic_tab_home_active.png\" alt=\"\" slot=\"icon-active\"&gt; 首页 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id='tab2'&gt; &lt;img src=\"../assets/images/ic_tab_subject_normal.png\" alt=\"\" slot=\"icon-normal\"&gt; &lt;img src=\"../assets/images/ic_tab_subject_active.png\" alt=\"\" slot=\"icon-active\"&gt; 书影音 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id='tab3'&gt; &lt;img src=\"../assets/images/ic_tab_status_normal.png\" alt=\"\" slot=\"icon-normal\"&gt; &lt;img src=\"../assets/images/ic_tab_status_active.png\" alt=\"\" slot=\"icon-active\"&gt; 广播 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id='tab4'&gt; &lt;img src=\"../assets/images/ic_tab_group_normal.png\" alt=\"\" slot=\"icon-normal\"&gt; &lt;img src=\"../assets/images/ic_tab_group_active.png\" alt=\"\" slot=\"icon-active\"&gt; 小组 &lt;/m-tabbar-item&gt; &lt;m-tabbar-item id='tab5'&gt; &lt;img src=\"../assets/images/ic_tab_profile_normal.png\" alt=\"\" slot=\"icon-normal\"&gt; &lt;img src=\"../assets/images/ic_tab_profile_active.png\" alt=\"\" slot=\"icon-active\"&gt; 我的 &lt;/m-tabbar-item&gt; &lt;/m-tabbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import mTabbar from '../components/tabbar' import mTabbarItem from '../components/tabbar-item' export default &#123; name: 'index', components: &#123; mTabbar, mTabbarItem &#125;, data()&#123; return&#123; select:'tab1' &#125; &#125;, watch:&#123; select:function()&#123; console.log(this.select); &#125; &#125; &#125;&lt;/script&gt; 1.父组件接收v-bind:value属性123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=\"m-tabbar\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:['value']&#125;&lt;/script&gt;&lt;style lang=\"less\"&gt;.m-tabbar&#123; display: flex; flex-direction: row; position: fixed; bottom: 0; left: 0; right: 0; width: 100%; overflow: hidden; height: 50px; background: #fff; border-top: 1px solid #e4e4e4;&#125;&lt;/style&gt; 2.子组件接收id属性值，通过$parent.$emit(‘input’,id)向父组件传递当前点击id的值，父组件由on来接收123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;a class=\"m-tabbar-item\" :class=\"&#123;'is-active':isActive&#125;\" @click=\"$parent.$emit('input',id)\"&gt; &lt;span class=\"m-tabbar-item-icon\" v-show=\"!isActive\"&gt;&lt;slot name=\"icon-normal\"&gt;&lt;/slot&gt;&lt;/span&gt; &lt;span class=\"m-tabbar-item-icon\" v-show=\"isActive\"&gt;&lt;slot name=\"icon-active\"&gt;&lt;/slot&gt;&lt;/span&gt; &lt;span class=\"m-tabbar-item-text\"&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/span&gt; &lt;/a&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:['id'], computed: &#123; isActive()&#123; if(this.$parent.value===this.id)&#123; return true; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"less\"&gt;.m-tabbar-item&#123; flex: 1; text-align: center; .m-tabbar-item-icon&#123; display: block; padding-top: 2px; img&#123; width: 28px; height: 28px; &#125; &#125; .m-tabbar-item-text&#123; display: block; font-size: 10px; color:#949494; &#125; &amp;.is-active&#123; .m-tabbar-item-text&#123; color: #42bd56; &#125; &#125;&#125;&lt;/style&gt;","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"}]},{"title":"IIS部署","slug":"iis部署","date":"2016-10-02T16:00:00.000Z","updated":"2017-08-25T12:51:31.140Z","comments":true,"path":"2016/10/03/iis部署/","link":"","permalink":"/2016/10/03/iis部署/","excerpt":"","text":"IIS名词介绍1.IIS简介 Internet Information Service 微软服务器，windows系统都自带这个功能 2.互联网相关名词介绍 服务器Server;通常是指服务器硬件。还有服务器软件（程序） 服务器软件是运行在电脑上的程序，电脑也可以当做一个服务器 URL：统一资源定位符 https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1492594445597&amp;di=1b28e8ff63505088aff8a1f3567bd44e&amp;imgtype=0&amp;src=http%3A%2F%2Fmvimg2.meitudata.com%2F55713dd0165c89055.jpg 域名domain name address: www.baidu.com ip地址：命令提示符 –&gt; ipconfig 使用ping www.baidu.com可以把域名转换成ip地址 DNS： Domain name system域名解析服务 开启IIS服务器123456789101112* 1.打开控制面板--&gt;程序--&gt;启用或关闭windows功能--&gt;internet information service--&gt;全部勾选* 2.使用localhost或者127.0.0.1访问本地服务器* 3.默认站点，IIS服务器默认站点在c:\\inetpub\\wwwroot文件夹下* 4.默认文档，打开服务器的时候加载显示的页面。可以上移提高优先级，也可以添加自己想要显示的页面。* 5.注意浏览器缓存，可能会加载以前缓存的页面，而没有加载自己添加的页面* 6.目录浏览，把服务器下的文件以目录的形式展示，这种方式很不安全，因为会把所有文件暴露出来* 7.开启目录浏览，需要把默认文档关掉或者删除所有的默认文档* 8.如果被人通过ip地址访问你的电脑。需要把防火墙关闭* 9.添加站点，端口需要改，要指定路径，如果不能访问，没有权限，需要修改权限* 10.文件夹--&gt;右键属性--&gt;安全--&gt;编辑--&gt;添加--&gt;everyone--&gt;全部控制--&gt;应用* 11.ftp文件传输协议，上传下载文件* 12.http超文本传输协议","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"代理","slug":"代理","permalink":"/tags/代理/"}]},{"title":"深入理解HTTP协议（转）","slug":"深入理解HTTP协议（转）","date":"2016-09-20T16:00:00.000Z","updated":"2017-08-25T11:21:24.000Z","comments":true,"path":"2016/09/21/深入理解HTTP协议（转）/","link":"","permalink":"/2016/09/21/深入理解HTTP协议（转）/","excerpt":"","text":"从浏览器地址栏输入url到显示页面的步骤(以HTTP为例) 在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树： Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树: 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 js解析如下： 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件 显示页面（HTML解析过程中会逐步显示页面）","categories":[{"name":"Http","slug":"Http","permalink":"/categories/Http/"}],"tags":[{"name":"页面请求","slug":"页面请求","permalink":"/tags/页面请求/"}]},{"title":"SUPERAGENT","slug":"批处理HTTP模块SuperAgent","date":"2016-09-09T16:00:00.000Z","updated":"2017-08-25T12:49:20.651Z","comments":true,"path":"2016/09/10/批处理HTTP模块SuperAgent/","link":"","permalink":"/2016/09/10/批处理HTTP模块SuperAgent/","excerpt":"","text":"最近在写爬虫，看了下node里面有啥关于ajax的模块,发现superagent这个模块灰常的好用。好东西要和大家分享，话不多说，开始吧～ 什么是SuperAgentsuperagent它是一个强大并且可读性很好的轻量级ajaxAPI，是一个关于HTTP方面的一个库，而且它可以将链式写法玩的出神入化。1var superagent = require('superagent'); superagent .post('/api') .send(&#123; 'key': 'value' &#125;) .set('header_key', 'header_value') .end(function(err, res) &#123; if (err) &#123; //do something &#125; else &#123; //do something &#125; &#125;) 接下来，让我们逐一的对SuperAgent的一些特性进行分析吧～🚀 设置请求头 这一点在写爬虫的时候十分的有用,因为有些网站可能设置了一些限制条件,比如它会去匹配你的请求头里面的一些字段, 像User-Agent Referer等,如果你没有设置这些请求头的话，可能就抓取不到数据咯～ SuperAgent里面设置请求头很简单,通过使用set()方法就可以设置了，有两种方式 单个单个的设置 1234567891011121314151617181920superagent .get('/api') .set('Referer','https://www.google.com') .set('Accept','image/webp,image/*,*/*;q=0.8') .end(function(req,res)&#123; //do something &#125;) 放在一起设置 superagent .get('/api') .set(&#123; 'Referer','https://www.google.com', 'Accept','image/webp,image/*,*/*;q=0.8' &#125;) .end(function(req,res)&#123; //do something &#125;) GET请求方式 我相信大家都一定见过这样类型的URL:http://localhost:8080/api和http://localhost:8080/api?id=1&amp;price=10,就是GET方式可以带上参数,也可以不带上参数。不带参数的就不说了,相信大家都会,在superagent中我们可以通过query()方法给URL后面带上参数,有4种写法 12345678910111213141516171819202122232425//接下来所形成的URL为/api?name=An&amp;age=20&amp;sex=male//第一种superagent .get(/api) .query(&#123;name:'An'&#125;) .query(&#123;age:20&#125;) .query(&#123;sex:'male'&#125;) .end(cb)//第二种superagent .get(/api) .query(&#123;name:'An',age:20,sex:'male'&#125;) .end(cb)//第三种 superagent .get(/api) .query('name=An&amp;age=20&amp;sex=male') .end(cb)//第四种 superagent .get(/api) .query('name=An') .query('age=20') .query('sex=male') .end(cb) head请求 head请求也可以通过query()的方式进行传递参数,大家可以参考👆的GET请求 POST/PUT请求 这两种请求，一般是要给服务端发送数据，现在文本数据的方式一般都以json的方式传递。我们可以在请求头里设置Accept=application/json，从而服务器可以根据请求头来生成json数据(在java开发后台时可以这样) 在superagent里面，默认的数据传递格式是json，所以下面几种种方式是相同的。 1234567891011121314151617superagent .post('/api') .set('Accept','application/json') .send('&#123;\"name\":\"An\",\"age\":20,\"sex\":\"male\"&#125;') .end(cb)//等价于 ==&gt;superagent .post('/api') .send(&#123;name:\"An\",age:20,sex:\"male\"&#125;) .end(cb)//等价于 ==&gt;superagent .post('/api') .send(&#123;name:\"An\"&#125;) .send(&#123;age:20&#125;) .sex(&#123;sex:'male'&#125;) .end(cb) 当然，除了json的形式去传递，我们还有一种很常见的表单提交，在superagent里，也实现了模拟表单的提交数据类型application/x-www-form-urlencoded， 我们可以通过type(&apos;form&apos;)方法进行转换 12345superagent .post('/api') .type('form') .send(&#123;name:'An',age:20&#125;) // name=An&amp;age=20 .end(cb) 有时候，我们也会在POST请求时，将一些参数放在URL上面，那这个时候还是可以用query()方法 设置Content-Type的两种快速方式 type()方法 accept()方法 这两种方法都可以接受规范的MIME格式,以及图片和xml等这些格式的数据。 123456789101112superagent .post('/api') .type('application/json') .type('png')// 等价于==&gt;superagent .post('/api') .accept('application/json') .accept('png') 分析处理response body superagent可以帮你解析返回的数据,当前支持三种类型的数据application/x-www-form-urlencoded application/json 和multipart/form-data JSON/Urlencoded 解析后的数据会以对象的形式存在,可以通过res.body来得到。 &apos;{&quot;name&quot;:&quot;An&quot;}&apos; //JSON String //解析 ==&gt; { name:&quot;An&quot; //JSON Object } Multipart 这种格式的数据的处理，superagent是通过Formidable模块，它是主要处理文件上传的模块，大家可以去了解下，也是Node里面十分常用的模块，也很简单易上手。上传的文件的信息可以在res.files去查看，当然，我觉得这个属性用的比较少，这只是个人观点了～ Response的属性 res.text包含为被解析的响应数据 res.body上文提到了，包含解析的数据，但是目前只支持三种格式 res.header响应头,是一个Object res.type &amp; res.charset 类型和编码格式 res.status状态码 终止请求 req.abort() 暂停请求 req.timeout(ms) ms表示毫秒为单位的时间 Basic Access Authentication 首先先简单的介绍下Basic Access Authenication，它是在web应用中，通过直接提供用户名、密码来进行验证身份的一种优化的解决方案。 原理是将用户名和密码通过:连接,形成username:password然后再进行base64加密，发送到服务器后再进行解密得到用户名和密码,进行进一步的匹配验证。参考文章:HTTP Basic Authentication认证。 在superagent里，有两种方式进行验证 12345678superagent .get('http://username:password@localhost') .end(cb)//等价于 ==&gt;superagent .get('http://localhost') .auth('username','password') .end(cb) 可以通过pipe管道流入流出数据 我想大家应该知道node里面有个核心特性就是stream，如果不知道的，可以参考:nodejs中流(stream)的理解,举两个栗子： 1234567891011121314//第一个例子var fs = require('fs');var request = require('superagent');var postJson = fs.createReadStream('./postDataJson');var req= request.post('/api');req.accept('json');stream.pipe(req);//第二个例子var fs = require('fs');var request = require('superagent');var getData = fs.createWriteStream('./getData');var res= request.get('/api');res.pipe(getData); 添加多个附件 superagent也提供了一些高级的API，如果你想添加多个附件可以使用attach(name,[path],[filename]),其中你可以通过filename来自定义上传后文件的文件名 12345request .post('/upload') .attach('avator','/path/a.png','An.png') .attach('photo','/path/b.png') .end(cb) 复合请求 superagent也支持复合请求,比如你想上传一个带有你的姓名和邮箱的图片，那可以通过field(name,value)方法 123456request .post('/upload') .field('name','An') .field('age':20) .attach('avator','/path/a.png','An.png') .end(cb) 错误处理 有时候我们可能会因为不同的原因得到4XX或者5XX的错误，这个时候我们确实是可以从end(function(err,res){...})里的err得到错误信息,比如er.status错误的状态码啥的，但是有些时候我们想去处理这些错误，重新发送一个别的请求啥的，那么这个时候我们可以通过on(&apos;error&apos;,handleFn)去处理了 12345request .post('/api') .send(data) .on('error',handleFn) .end(cb);","categories":[{"name":"Node","slug":"Node","permalink":"/categories/Node/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"/tags/中间件/"},{"name":"http请求","slug":"http请求","permalink":"/tags/http请求/"}]},{"title":"懒加载原理","slug":"懒加载","date":"2016-09-04T16:00:00.000Z","updated":"2017-08-25T12:49:14.448Z","comments":true,"path":"2016/09/05/懒加载/","link":"","permalink":"/2016/09/05/懒加载/","excerpt":"","text":"懒加载的原理 原理：先将img标签中的src链接设为同一张图片（空白图片），将其真正的图片地址存储再img标签的自定义属性中（比如data-src）。当js监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到src属性中，达到懒加载的效果。 这样做能防止页面一次性向服务器响应大量请求导致服务器响应慢，页面卡顿或崩溃等问题。 代码实现 既然懒加载的原理是基于判断元素是否出现在窗口可视范围内，首先我们写一个函数判断元素是否出现在可视范围内： 12345678910function isVisible($node)&#123; var winH = $(window).height(), scrollTop = $(window).scrollTop(), offSetTop = $(window).offSet().top; if (offSetTop &lt; winH + scrollTop) &#123; return true; &#125; else &#123; return false; &#125;&#125; 再添加上浏览器的事件监听函数，让浏览器每次滚动就检查元素是否出现在窗口可视范围内： 12345$(window).on(\"scroll\", function&#123; if (isVisible($node))&#123; console.log(true); &#125;&#125;) 我们已经很接近了，现在我们要做的是，让元素只在第一次被检查到时打印true，之后就不再打印了 1234567891011var hasShowed = false;$(window).on(\"sroll\",function&#123; if (hasShowed) &#123; return; &#125; else &#123; if (isVisible($node)) &#123; hasShowed = !hasShowed; console.log(true); &#125; &#125;&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"懒加载","slug":"懒加载","permalink":"/tags/懒加载/"},{"name":"lazyload","slug":"lazyload","permalink":"/tags/lazyload/"}]},{"title":"解决https请求下发送http请求问题","slug":"解决https请求下发送http请求问题 ","date":"2016-08-24T16:00:00.000Z","updated":"2017-08-25T12:26:26.803Z","comments":true,"path":"2016/08/25/解决https请求下发送http请求问题 /","link":"","permalink":"/2016/08/25/解决https请求下发送http请求问题 /","excerpt":"","text":"在https页面下的带有相对路径的请求都会与页面的协议保持一致。如果想在https页面下发送http的请求，如果只把链接写死成为http的\b绝对路径是不够的，这样会导致http的请求与总页面https的请求的session不一致。 为什么呢？原因是https的请求中服务器发回的cookie是标记为”secure”的，而http的请求时非”secure”,”由于在服务器端secure”的cookie不会兼容非”secure”的，所以当http的请求携带着同一jsessionid的cookie到达服务器时，服务器拒绝非”secure”，进而返回的结果是一个新的非”secure”的cookie，于是两个session就不同了。 怎么解决呢？由原因分析可知，两个session不同，更具体说是cookie的状态不同。那么办法是，在接收到第一个https请求的响应后 到 发送下面的http请求之前，将cookie去”secure”状态，但是又要保证jsessionid不变。具体操作可以新建一个cookie(新建的是非”secure”状态)，然后赋予同一个jessionid，然后加入response中。 代码如下： 1234Cookie cookie = new Cookie(\"JSESSIONID\", req.getSession().getId());cookie.setPath(req.getContextPath());resp.addCookie(cookie); 本文转载自http://blog.csdn.NET/songgeabc/article/details/18192057","categories":[{"name":"Http","slug":"Http","permalink":"/categories/Http/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"/tags/跨域/"}]},{"title":"JavaScript深入之闭包(转)","slug":"闭包","date":"2016-08-19T16:00:00.000Z","updated":"2017-08-25T12:43:39.284Z","comments":true,"path":"2016/08/20/闭包/","link":"","permalink":"/2016/08/20/闭包/","excerpt":"","text":"JavaScript深入之闭包 介绍理论上的闭包和实践上的闭包，以及从作用域链的角度解析经典的闭包题。 定义MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量 举个例子1234567var a = 1;function foo() &#123; console.log(a);&#125;foo(); foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛…… 还真是这样的！ 所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。 咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？ 别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义： ECMAScript中，闭包指的是： 1.从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 2.从实践角度：以下函数才算是闭包： (1).即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） (2).在代码中引用了自由变量 分析1234567891011var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;var foo = checkscope();foo(); 首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。 另一个与这段代码相似的例子，在《JavaScript深入之执行上下文》中有着非常详细的分析。如果看不懂以下的执行过程，建议先阅读这篇文章。 这里直接给出简要的执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？ 以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……) 然而 JavaScript 却是可以的！ 必刷题1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为：123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的作用域链为：123data[0]Context = &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。 data[1] 和 data[2] 是一样的道理。 所以让我们改成闭包看看：12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function (i) &#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125;data[0]();data[1]();data[2](); 当执行到 data[0] 函数之前，此时全局上下文的 VO 为：123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 跟没改之前一模一样。 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125; 匿名函数执行上下文的 AO 为：123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是 0。 data[1] 和 data[2] 是一样的道理。 转自 https://juejin.im/post/590159d8a22b9d0065c2d918","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"git远程操作","slug":"git远程操作","date":"2016-08-14T16:00:00.000Z","updated":"2017-08-25T12:25:22.668Z","comments":true,"path":"2016/08/15/git远程操作/","link":"","permalink":"/2016/08/15/git远程操作/","excerpt":"","text":"git远程操作 在开源中国的码云平台做代码的远程提交 12345678910111213码云地址:https://git.oschina.net登录注册:此步骤省略具体操作步骤true1. 在平台上通过新建项目创建一个代码仓库true2. 把远程仓库的代码clone到本地truetrue在本地电脑上创建一个文件夹(通过cd命令进入此文件夹)，执行以下命令truetruegit clone https://.... # 通过clone命令把代码clone到本地true3. 使用编辑器打开文件夹,对内容做修改true4. 修改之后对代码做本地的缓存和提交truetruegit add . #把文件加入缓存区truetruegit commit -m '提交信息' #把代码提交到本地仓库true5. 把本地代码push(推送)到远程服务器truetruegit push git客户端gui工具 tortoisegit sourcetree github上创建个人主页 在github上创建一个项目名为 xxx.github.io的仓库此仓库中放置的静态html文件可以直接通过外网地址进行访问 创建个人github主页的步骤为 1231. 打开github,登陆个人账号2. 创建项目,项目名为 用户名.github.io3. 在此项目中提交一些可以直接访问的静态html文件 查看、添加、提交、删除、找回，重置修改文件git help # 显示command的help git show # 显示某次提交的内容 git show $id git co – # 抛弃工作区修改 git co . # 抛弃工作区修改 git add # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm # 从版本库中删除文件 git rm –cached # 从版本库中删除文件，但不删除文件 git reset # 从暂存区恢复到工作文件 git reset – . # 从暂存区恢复到工作文件 git reset –hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am “some comments” git ci –amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件diffgit diff # 比较当前文件和暂存区文件差异 git diff git diff &lt; id2&gt; # 比较两次提交之间的差异 git diff .. # 在两个分支之间比较 git diff –staged # 比较暂存区和版本库差异 git diff –cached # 比较暂存区和版本库差异 git diff –stat # 仅仅比较统计信息 查看提交记录git log git log # 查看该文件每次提交记录 git log -p # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log –stat #查看提交统计信息 tig Mac上可以使用tig代替diff和log，brew install tig Git 本地分支管理 查看、切换、创建和删除分支git br -r # 查看远程分支 git br # 创建新的分支 git br -v # 查看各个分支最后提交信息 git br –merged # 查看已经被合并到当前分支的分支 git br –no-merged # 查看尚未被合并到当前分支的分支 git co # 切换到某个分支 git co -b # 创建新的分支，并且切换过去 git co -b # 基于branch创建新的new_branch git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git co $id -b # 把某次历史提交记录checkout出来，创建成一个分支 git br -d # 删除某个分支 git br -D # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebasegit merge # 将branch分支合并到当前分支 git merge origin/master –no-ff # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master # 将master rebase到branch，相当于： git co &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge Git补丁管理(方便在多台机器上开发同步时用) git diff &gt; ../sync.patch # 生成补丁 git apply ../sync.patch # 打补丁 git apply –check ../sync.patch #测试补丁能否成功 Git暂存管理git stash # 暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地 git pull –no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 git fetch origin # 抓取远程仓库更新 git merge origin/master # 将远程主分支合并到本地当前分支 git co –track origin/branch # 跟踪某个远程分支创建相应的本地分支 git co -b origin/ # 基于远程分支创建本地分支，功能同上 git push # push所有分支 git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin # 创建远程分支， origin是远程仓库名 git push origin : # 创建远程分支 git push origin : #先删除本地分支(git br -d )，然后再push删除远程分支 Git远程仓库管理GitHubgit remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址 git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm # 删除远程仓库 创建远程仓库git clone –bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git –bare init # 在服务器创建纯仓库 git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库git branch –set-upstream master origin/master git branch –set-upstream develop origin/develop","categories":[{"name":"版本管理","slug":"版本管理","permalink":"/categories/版本管理/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}]},{"title":"CSS兼容","slug":"css兼容","date":"2016-08-11T16:00:00.000Z","updated":"2017-08-25T12:23:18.888Z","comments":true,"path":"2016/08/12/css兼容/","link":"","permalink":"/2016/08/12/css兼容/","excerpt":"","text":"一、基本的css兼容：1.hack 可能很多人喜欢用css hack的形式去兼容ie浏览器，但是我自己用起来感觉其实不好使 。ie7-就不考虑了，问题在哪呢，就在ie8的甑别上，你怎么让样式只对ie8起作用。1234.selector &#123; color: #ff0\\0;/*ie8*/ color: #f00\\9\\0;/*ie9+*/&#125; （这个hack是可以区分ie8和ie9的，之前由于未知原因导致浏览器测试不成功，重装系统后发现是可用的，后来又在多台机器上测试过，证明是正确的。很抱歉误导了大家，特此修正，仍然建议用文档注释的方式去独立写hack，当然最好是可以优雅降级，避免使用css hack。） ２．注释 更好用的是什么呢，是用ie浏览器独有的文档注释的方式。像这样：12345&lt;!DOCTYPE html&gt;&lt;!--[if IE 8 ]&gt; &lt;html class=\"ie8\" lang=\"en\"&gt; &lt;![endif]--&gt;&lt;!--[if IE 9 ]&gt; &lt;html class=\"ie9\" lang=\"en\"&gt; &lt;![endif]--&gt;&lt;!--[if (gt IE 9)|!(IE)]&gt;&lt;!--&gt;&lt;html lang=\"en\"&gt; &lt;!--&lt;![endif]--&gt; 好处：可以独立的维护处理兼容ie浏览器的样式表，又不会淹没在一大堆css hack标识中，只需要在独立对ie8应用样式规则的地方，copy该条规则，然后在前面加上 .ie8然后就能随便写了，对付ie9也一样。 3. 对于360双核这种找抽浏览器，据说添加以下头部meta信息可以使得网页用webkit内核渲染：1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; IE=edge：保持使用最高级别模式显示内容； chrome=1：谷歌的外挂插件Google Chrome Frame（谷歌内嵌浏览器框架GCF），使用IE浏览网页时实际上是使用Chrome浏览器内核渲染，最低支持IE6，但前提是客户端已经安装GCF。 但实际上这个meta标识是ie浏览器所识别的（详情：ies-compatibility-features-for-site-developers/)，并不是公认的标准，所以用双核的浏览器会傲娇。当然360也会傲娇，所以有时你会发现360并不能总是（也可能是我本人rp差）以chrome内核渲染你的按现代标准开发的网页。 那么试试这个吧，添加： 这个meta标识是360自家实现的(详情：meta.html)，表示强制要求360这造福中国社会万千网民的浏览器用chrome的内核渲染网页。 ok，一行代码搞定360绝大部分的兼容。 ————————以下转———————————————- 二、ie8的css兼容现在说说ie8下的css问题： 1、ie8支持:first-child,但不支持:last-child。因为前者是css2.1标准，后者是css3标准。参下：1CSS 2.1 selectors：Basic CSS selectors including: * (universal selector), &gt; (child selector), :first-child, :link, :visited, :active, :hover, :focus, :lang(), + (adjacent sibling selector), [attr], [attr=\"val\"], [attr~=\"val\"], [attr|=\"bar\"], .foo (class selector), #foo (id selector) 2、 为什么会发现上面的奇怪的东西（怪我css2.1和css3分不清），因为编译sass文件后发现ie8下的样式基本全歇菜了。需要注意的是，如果浏览器 不支持的选择器和支持的选择器写在一起，那么整条规则就不起作用了。比如你不小心创造了一个伪元素（是真的伪哦）.bb:bb-child, .cc{background:#333;}那么这整条规则就不起作用了，所有浏览器在此情况下都会歇菜,.cc的样式就丢失了。3、 input设置了左右padding，but输入较多内容时padding还是会消失。这个问题是无解的，ie浏览器她就是这么渲染input的，解决方法是在input 外面套一层div，用div设置左右padding，border，width和height，input只需要设置width和weight为100% 即可。另外，正常来讲，如果没有明确设置height的值，那么设置的line-height值就是height的值，but对于ie8，如果input 设置了 line-height，那么input必须设置height，否则input的内容显示有问题，会上下隐藏部分内容，她就是要躲猫猫。4、 为什么上面我不用input的伪元素进行设置而要嵌套多一层div呢？因为input，img，iframe等元素不支持伪元素 -_-||。:before 和:after伪元素指定了一个元素文档树内容之前和之后的内容。与’content’属性联用,指定了插入的内容（也就是你必须显性设置content 属性这两个伪家伙才能在文档中显示出来，哪怕设置content属性为空字符串也行）。作为DOM元素，伪元素都是在容器内进行渲染的, input，img，iframe等元素都不能包含其他元素，也就是不是容器，所以不能通过伪元素插入内容。5、 table中如果不是严格的用于表格，而是用于奇葩的局部布局时（我也想问为什么用来布局。。），td设置成inline-block可以排成一行，但是 ie8和ie9 下，如果td中的内容很长，即使td设置了宽度，td也会撑开并占用td设置的margin（废话，td是没有margin可言的），直到挤占所有的td 宽度之和为tr的宽度。但是td设置成float：left；就能表现成block。这个不清楚为什么，但是管用。。6、父元素的左padding会和子元素的左margin重叠。这个是没有好好实现盒子模型的事情了，包容吧。。7、sprite图中的icons之间最好留空白间隔，哪怕间隔1px也好，否则ie8下会出现使用了某一个icon当背景，icon后面跟着的其他icon也顺带显示了一小部分的bug，所以icons之间还是要适当留白，不要太省。三、ie11部分css问题1、 ie11下很多元素表现和其他浏览器不一致，比如对应用了同一样式（不设置 高度）的div，其他浏览器解析的高度是一致的，但是ie11下该div有可能高度偏大，由此导致一些排版上的问题，所以，如果发现元素排版上下偏移的问题，查看此元素或其当代元素是否设置了高度，统一添上高度一切都ok了。2、抱歉，ie11问题确实不多。四、结尾附上一个关于css优先级的奇谈首先我们知道： 1、id选择器优先级权重比class选择器大一个数量级，class选择器权重比标签选择器大一个数量级；2、class选择器和属性选择器同优先级;3、样式的优先程度需要根据第1条规则计算整体的优先级，按选择器权重计算各条样式规则中所有选择器优先级之和，哪条规则权重大，那条就说了算。如果相同那么后面的覆盖前面的。4、像这种.dog &gt; p开挂，多了特殊符号的，并不会增加优势，还是和 .dog p优先级一样。然后可以抛出一个问题了： 对于下面的文档结构，分别对 p | .p | div p | .parent | #parent设置color属性，那么优先级如何呢？123&lt;div id=\"parent\" class=\"parent\"&gt; &lt;p class=\"p\"&gt;p&lt;/p&gt;&lt;/div&gt; 结果表现：也就是 .p &gt; div p &gt; p &gt; #parent &gt; .parentid选择器居然比p选择器优先级还低！将p元素和div元素分开看，.p &gt; div p &gt; p 很正常， #parent &gt; .parent也很正常。所以问题关键在子级p和父级#parent, 子级的选择器优先级比父级的选择器优先级高，或者说继承的优先级程度比自身的优先级低！ 嵌套多一层看看就知道是不是了，分别对#parent | div | p设置color属性：1234567&lt;div id=\"parent\" class=\"parent\"&gt; &lt;div class=\"mid\"&gt; &lt;p id=\"p\" class=\"p\"&gt;p&lt;/p&gt; &lt;div&gt;&lt;/div&gt; 结果确实是p &gt; div &gt; #parent： 即使应用两个选择器也无济于事，依然是p &gt;#parent div 只要能定位到p元素，那么父级选择器的权重就起作用了,一试便知，对#parent p | #p 设置同样的样式结果是这样的：嗯，确实如此。所以： 5、css样式优先级还和继承有关，继承的优先级不如本身应用的优先级高。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"}]},{"title":"js简单了解上下文","slug":"js简单了解上下文","date":"2016-02-02T16:00:00.000Z","updated":"2017-08-25T13:05:05.112Z","comments":true,"path":"2016/02/03/js简单了解上下文/","link":"","permalink":"/2016/02/03/js简单了解上下文/","excerpt":"","text":"定义 在JavaScript中，你的代码将总是有着某种形式的上下文(代码在其内部工作的 对象)。这也是其它面向对象语言所共有的功能，但它们都不如JavaScript处理得这样极端。上下文是通过变量this工作。变量this总是引用代 码当前所在的那个对象。记住全局对象实际上是window对象的属性。这意味着即使是在全局上下文里，this 变量仍然引用一个对象。上下文可以成为一个强大的工具，是面向对象代码不可或缺的一环。程序1展示了一些关于上下文的简单例子。12345678910111213141516171819202122代码 var obj = &#123; yes: function ()&#123; // this == obj this .val = true ; &#125;, no: function ()&#123; this .val = false ; &#125; &#125;; // 我们看到，obj对象没有\"val\"的属性 alert( obj.val == null ); // 我们运行yes函数，它将改变附着在obj 对象的val属性 obj.yes(); alert( obj.val == true ); // 然而，我们现在让window.no指向obj.no方法，并运行之 window.no = obj.no; window.no(); // 这导致obj对象保持不变(上下文则切换到了window对象)， alert( obj.val == true ); // 而window的val属性被更新 alert( window.val == false );","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]}]}